<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Java 泛型 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="一般的类和方法，只能使用具体的类型，如果要编写可以应用于多种类型的代码，那么这种刻板的限制对代码的限制就会很大。
在面向对象编程语言中，多态算是一种泛化机制。可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类导出的任何类作为参数。但程序还是会受到继承的限制，比如java中就是单继承体系。如果将方法的参数设为一个接口，那么限制会松很多，任何实现了该接口的类都能满足该方法，包括暂时那些还不存在的类。    
但有时即便使用了接口，对程序的约束还是太强。因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望能编写更通用的代码，能够应用于”某种不具体的类型”，而不是一个具体的接口或者类。
泛型实现了”参数化类型”的概念，使代码可以应用于多种类型。其最初的目的是希望类或方法能够具备最广泛的表达能力，通过解耦类或方法与所使用的类型之间的约束。   只是java中的泛型并没有这样高的追求，它的目的只是用来告诉编译器类或方法希望使用的参数类型，以便编译器能够确保编译时参数都是期望的类型。实际上在编译之后参数的类型信息都会被擦除成边界类型，这样保证在运行时不会出现类型错误。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java 泛型"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  110 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20170603" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2017-06-02T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2017/06/03/20170603/" style="color: #736f6f;">2017-06-03</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        Java 泛型
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 4k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 16min</font>
   
   
  
  <div class="categories">
    <a href="/categories/Java-SE/">Java SE</a>
  </div>


   
   

   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>一般的类和方法，只能使用具体的类型，如果要编写可以应用于多种类型的代码，那么这种刻板的限制对代码的限制就会很大。</p>
<p>在面向对象编程语言中，多态算是一种泛化机制。可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类导出的任何类作为参数。但程序还是会受到继承的限制，比如java中就是单继承体系。如果将方法的参数设为一个接口，那么限制会松很多，任何实现了该接口的类都能满足该方法，包括暂时那些还不存在的类。    </p>
<p>但有时即便使用了接口，对程序的约束还是太强。因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望能编写更通用的代码，能够应用于”某种不具体的类型”，而不是一个具体的接口或者类。</p>
<p>泛型实现了”参数化类型”的概念，使代码可以应用于多种类型。<font color="#E51508">其最初的目的是希望类或方法能够具备最广泛的表达能力，通过解耦类或方法与所使用的类型之间的约束</font>。   只是java中的泛型并没有这样高的追求，它的目的只是用来告诉编译器类或方法希望使用的参数类型，以便编译器能够确保编译时参数都是期望的类型。实际上在编译之后参数的类型信息都会被擦除成边界类型，这样保证在运行时不会出现类型错误。<br><a id="more"></a></p>
<h3 id="1-泛型类-接口"><a href="#1-泛型类-接口" class="headerlink" title="1. 泛型类/接口"></a>1. 泛型类/接口</h3><p>容器类是促成泛型出现的主要原因之一，泛型之于容器的意义在于可以指定容器持有何种确定类型的对象，并且由编译器来保证类型的正确性。比如这里的<code>ArrayList&lt;E&gt;</code>，可以在使用时再指定参数的具体类型。   </p>
<figure class="highlight java"><figcaption><span class="caption">java.util.ArrayList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过如果打出两个实例的类型，会发现它们都是<code>java.util.ArrayList</code>，这是因为在编译时参数类型被擦除了。<font color="#E51508">虽然java提供了一些方法用来获取泛型参数列表，但是除了能获取类型占位符之外并没有其它什么作用</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Double&gt; doubleList = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(integerList.getClass() == doubleList.getClass()); <span class="comment">//true</span></span><br><span class="line">System.out.println(integerList.getClass().getName()); <span class="comment">// java.util.ArrayList</span></span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.asList(integerList.getClass().getTypeParameters())); <span class="comment">//[E]</span></span><br></pre></td></tr></table></figure>
<p>这里<code>ArrayList&lt;E&gt;</code>除了自身是泛型类之外，它的父类以及实现的接口也都是泛型的。其实<font color="#E51508">泛型类在继承和接口实现体系中都是很常见的，子类可以决定是否将父类的泛型参数指定为具体类型，当然也可以增加自己的泛型参数，</font>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">selfun</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2. 泛型方法"></a>2. 泛型方法</h3><p>定义泛型方法，只需要将泛型参数列表置于返回值之前即可。<font color="#E51508">泛型方法可以独立于泛型类，也就是说，是否拥有泛型方法与其所在的类是否是泛型类没有关系。而且，通常应该优先考虑使用泛型方法，因为这样能让事情更加清楚明白</font>。   </p>
<figure class="highlight java"><figcaption><span class="caption">java.util.Arrays</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Arrays.asList</code>利用了参数类型推断，而且与可变参数结合起来使用。其实它是它返回的是一个内部实现类的实例，但是没有实现add或remove，如果调用的话将得到一个<code>UnsupportedOperationException</code>异常。不过我们也可以利用类型推断编写一个类似的工具：</p>
<figure class="highlight java"><figcaption><span class="caption">ListUtil</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">newArrayList</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">LinkedList&lt;T&gt; <span class="title">newLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">unionAll</span><span class="params">(List&lt;T&gt; a, List&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">        list.addAll(b);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">diff</span><span class="params">(Set&lt;T&gt; a, List&lt;T&gt; b)</span></span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">        list.removeAll(b);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">asArrayList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;T&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;(args.length);</span><br><span class="line">        <span class="keyword">for</span>(T item : args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">LinkedList&lt;T&gt; <span class="title">asLinkedList</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;T&gt; list =  <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item : args)&#123;</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = ListUtil.newLinkedList();</span></span><br></pre></td></tr></table></figure>
<h3 id="3-边界符"><a href="#3-边界符" class="headerlink" title="3. 边界符"></a>3. 边界符</h3><p>编译器会将泛型参数擦除为它的第一个边界类型，因此如果我们改变了边界就是改变了擦除后的类型，也就作用到了是运行时。</p>
<p>比如比较两个List是否相同:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends List&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(T t1, T t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.equals(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这与直接定义为边界类型并没有区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(List t1, List t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.equals(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此<font color="#E51508">通常只有当你希望代码能够跨多个类工作时，使用泛型才能有所帮助。并不是说extends没有用，如果一个类的方法返回的是T的子类，那么使用泛型就可以返回一个确切的类型。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReturnGenericType&lt;ArrayList&gt; t = new ReturnGenericType();</span></span><br><span class="line"><span class="comment">// ArrayList arrayList = t.get();</span></span><br></pre></td></tr></table></figure>
<h3 id="4-类型擦除"><a href="#4-类型擦除" class="headerlink" title="4. 类型擦除"></a>4. 类型擦除</h3><p>采用擦除的方式实现泛型是为了支持兼容性而不得不做的一个折中，使原先没有使用泛型的类库与使用了泛型的类库能够一起运行。<font color="#E51508">由于擦除丢失了在泛型代码中执行某些操作的能力，任何在运行时需要知道确切类型信息的操作都将无法工作</font> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> T)&#123;&#125; <span class="comment">//Error</span></span><br><span class="line">		</span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T(); <span class="comment">//Error</span></span><br><span class="line">		</span><br><span class="line">        T[] arr = <span class="keyword">new</span> T[<span class="number">10</span>]; <span class="comment">//Error</span></span><br><span class="line">		</span><br><span class="line">        T[] arr = (T)<span class="keyword">new</span> Object[<span class="number">10</span>]; <span class="comment">//Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-类型检测"><a href="#4-1-类型检测" class="headerlink" title="4.1. 类型检测"></a>4.1. 类型检测</h4><p>对于<code>instanceof</code>，如果引入类型标签，则可以使用动态的<code>isInstance</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeCapture</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">    Class&lt;T&gt; type;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeCapture</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-实例创建"><a href="#4-2-实例创建" class="headerlink" title="4.2. 实例创建"></a>4.2. 实例创建</h4><p>java的解决办法是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象便是Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">IGenerator&lt;T&gt; <span class="title">get</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Generator&lt;&gt;(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种方式要求使用者自己清楚类的构造器，否则像这里，如果创建实例的类没有默认构造器，那么将会发生运行时异常，而且在编译期间无法捕获。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IGenerator&lt;Integer&gt; generator = Generator.get(Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">int</span> i = generator.create();</span><br></pre></td></tr></table></figure>
<p>因此，建议使用显式的工厂，并限制其类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerGenerator</span> <span class="keyword">implements</span> <span class="title">IGenerator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;G extends IGenerator&lt;T&gt;, T&gt; <span class="function">T <span class="title">create</span><span class="params">(G generator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> generator.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式都传递了工厂对象，但Class<T>是内建的，而上面的方式是显式创建的，可以获得编译期检查。</p>
<h4 id="4-3-泛型数组"><a href="#4-3-泛型数组" class="headerlink" title="4.3. 泛型数组"></a>4.3. 泛型数组</h4><p>成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。数组的类型将在数组被创建时确定，因此可以在创建时给它需要的类型，然后在使用之前再将其转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Generator&lt;Integer&gt;[] garr;</span><br><span class="line">garr = (Generator&lt;Integer&gt;[])<span class="keyword">new</span> Generator[<span class="number">100</span>];</span><br><span class="line">System.out.println(garr.getClass().getSimpleName()); <span class="comment">//Generator[]</span></span><br><span class="line"></span><br><span class="line">garr[<span class="number">0</span>] = <span class="keyword">new</span> Generator&lt;Integer&gt;(<span class="keyword">null</span>);</span><br><span class="line">Generator&lt;Integer&gt; g = garr[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>考虑一个简单的泛型数组包装器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">    T[] array;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array = (T[])<span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span></span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于擦除，可以知道在运行时数组的实际类型为Object[]，并且<code>put</code>和<code>get</code>在方法调用的边界处限制了数组元素的实际类型为参数类型，<br>因此可以将<code>GenericArray</code>当成泛型数组来使用。但是如果试图调用<code>rep()</code>来获取T[],那么只能用Object[]来接收，否则将出现运行时异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericArray&lt;Integer&gt; array = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">Integer[] arr = array.rep(); <span class="comment">//ClassCastException</span></span><br></pre></td></tr></table></figure></p>
<p>事实上任何想使用泛型数组的地方都可以通过<code>ArrayList</code>来解决，它在内部使用Object[]，然后当使用数组元素时，添加一个对参数类型的转型。</p>
<h3 id="5-通配符"><a href="#5-通配符" class="headerlink" title="5. 通配符"></a>5. 通配符</h3><p>通配符<font color="#E51508"> ? 并不意味着可以是任何类型，而是指一个特定的类型，只是这个类型可以是任何一种</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-extends"><a href="#5-1-extends" class="headerlink" title="5.1. extends"></a>5.1. extends</h4><p>先看一个关于数组的问题：数组是协变的，它在语言中是完全定义的，内建了编译期和运行时检查，因此可以将导出类型的数组赋予基类型的数组引用。但是如果使用不当将会出现运行时异常并且编译器无法检测。     </p>
<p><strong>协变</strong>：如果B是A的子类，并且F(B)也是F(A)的子类，那么F即为协变；<br><strong>逆变</strong>：如果B是A的子类，并且F(B)成了F(A)的父类，那么F即为逆变；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">    fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple();</span><br><span class="line">    fruit[<span class="number">1</span>] = <span class="keyword">new</span> Orange();  <span class="comment">// 可以编译但运行异常: ArrayStoreException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 Apple 数组并赋值给一个 Fruit 数组的引用，数组对象发生了一个向上转型。那么对于编译器来说，它认为 fruit 可以存储任何 Fruit 及其子类型的实例，而运行时的数组机制知道它实际处理的应该是Apple，因此会抛出异常。</p>
<p>泛型可以将这种错误检测移入到编译期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="comment">//compile Error</span></span><br></pre></td></tr></table></figure>
<p>不能把一个涉及 Apple 的泛型赋给一个赋给 Fruit 的泛型，因为由于编译之后它们都被擦除为Object，编译器根本不知道它们的实际类型，因此它拒绝向上转型。如果想在两个类型之间建立某种向上转型关系，那么可以使用通配符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">Apple apple = (Apple)list.get(<span class="number">0</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> Apple()); <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure>
<p>这里<code>List&lt;? extends Fruit&gt;</code>表示List将持有Fruit的某种具体的子类型，只是为了向上转型，并不关心它具体是哪种子类型。<font color="#E51508">一旦执行这种向上转型，将丢失向其中传递任何对象的能力，甚至传递Object也不行。因为编译器已经无法知道List持有的具体类型，因此它将直接拒绝对参数列表中涉及通配符方法的调用。</font>不过，如果是返回参数的话，比如get，那么可以确定通配符代表的至少是一个Fruit。</p>
<p>这就可以解释为什么上面ArrayList中的<code>remove</code>、<code>contains</code>、<code>indexof</code>等方法的参数是Object了，只有这样这些方法的调用才能不受泛型通配符的影响。    </p>
<p>另外，这些方法都有一个共同点，就是它们的行为只依赖equals的执行结果，而equals并不要求必须是相同的类型，每个类都可以自定义自己equals的实现，所以如果用参数类型作为方法参数反而限制了方法的语义。比如对于<code>ArrayList</code>与<code>LinkedList</code>，它们的<code>equals</code>都在<code>AbstractList</code>中实现，只要集合中的元素一样就成立，并不区分是哪种子类型。解释来自<a href="https://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="noopener">stackoverflow</a></p>
<blockquote>
<p>As mentioned by others, the reason why get(), etc. is not generic because the key of the entry you are retrieving does not have to be<br>the same type as the object that you pass in to get(); the specification of the method only requires that they be equal. This follows<br>from how the equals() method takes in an Object as parameter, not just the same type as the object.</p>
</blockquote>
<h4 id="5-2-super"><a href="#5-2-super" class="headerlink" title="5.2. super"></a>5.2. super</h4><p>使用超类型通配符可以解决上面list的问题，即声明通配符是由某个特定类的任何基类来界定的，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Fruit()); </span><br><span class="line">list.add(<span class="keyword">new</span> Orange()); </span><br><span class="line">list.add(<span class="keyword">new</span> Apple());  </span><br><span class="line">Object fruit = list.get(<span class="number">0</span>);</span><br><span class="line">Apple apple = (Apple)list.get(<span class="number">1</span>); <span class="comment">//ClassCastException</span></span><br></pre></td></tr></table></figure></p>
<font color="#E51508">现在可以确定list允许持有的是Fruit的某种超类，因此它的方法参数至少能够接收Fruit及其子类。但是反之要从list中获取的话，
对编译器来说，只能确定它是一个Object。而对调用者来说可以确定list中实际持有的至多是Fruit，那么强转为Fruit是安全的，
但如果想转型为具体的子类型的话，则可能发生运行时异常，而且编译器无法检查。</font>

<p>其实相当于extends给定了 ? 的上界，而super给定了下界，对于容器来说它们的范围都是一样的，只是开口方向不一样。可以用PECS原则来总结：producer-extends, consumer-super。即extends，只能读，相当于生产者向外产出；而super，只能写，相当于消费者只能接收消费；在一些api中可以见到这种应用，比如：</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.Collections</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcSize = src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source does not fit in dest"</span>);</span><br><span class="line">    <span class="comment">//如果实现了RandomAccess直接下标访问，否则通过迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD || (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-自限定类型Comparable"><a href="#6-自限定类型Comparable" class="headerlink" title="6. 自限定类型Comparable"></a>6. 自限定类型Comparable</h3><p>由于泛型没有类型信息，因此不能直接继承一个泛型参数，但是可以继承一个使用泛型的基类，并且用自身作为基类的参数类型，比如Comparable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样基类用子类代替其参数，相当于泛型基类变成了其子类的功能模板，并且这些功能的参数和返回值都使用的子类型本身，最终，自限定保证了参数类型必须与正在被定义的类相同。    </p>
<p>最常见的就是对于<code>Comparable</code>的使用，比如定义一个求集合中最大值的工具方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; collection)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的方法限制太强，只允许自己与自己比较，可以给定边界，允许自己与自己的子类进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt; Collection)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><strong>参考：</strong></p>
<ol>
<li>《Java编程思想》</li>
<li><a href="https://www.cnblogs.com/sanzao/p/10415035.html" target="_blank" rel="noopener">https://www.cnblogs.com/sanzao/p/10415035.html</a></li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2017/06/04/20170604/">
		    Java 枚举
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2017/06/02/20170602/">
		    Java Exception
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/Java-SE/">Java SE</a>
  </div>


        

         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
    $("#xx_ul").click(function(){ $("#xx_li").toggle(); });
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-泛型类-接口"><span class="toc-text">1. 泛型类&#x2F;接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-泛型方法"><span class="toc-text">2. 泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-边界符"><span class="toc-text">3. 边界符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-类型擦除"><span class="toc-text">4. 类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-类型检测"><span class="toc-text">4.1. 类型检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-实例创建"><span class="toc-text">4.2. 实例创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-泛型数组"><span class="toc-text">4.3. 泛型数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-通配符"><span class="toc-text">5. 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-extends"><span class="toc-text">5.1. extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-super"><span class="toc-text">5.2. super</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-自限定类型Comparable"><span class="toc-text">6. 自限定类型Comparable</span></a></li></ol>
</div>





  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2023 &nbsp;&nbsp; shanhm1991 &nbsp;&nbsp; version@1.0.0 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
