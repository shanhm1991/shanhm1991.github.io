<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>《Java并发编程实战》 线程安全性的委托 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="委托是创建线程安全类的一个最有效策略：只需让现有的线程安全类管理所有的状态即可。Java类库包含丰富的并发构建模块，如线程安全容器以及各种用于协调多个相互协作的线程的同步工具类。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《Java并发编程实战》 线程安全性的委托"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  109 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20190104" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-01-03T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2019/01/04/20190104/" style="color: #736f6f;">2019-01-04</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        《Java并发编程实战》 线程安全性的委托
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 6.8k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 26min</font>
   
   
  
  <div class="categories">
    <a href="/categories/Java并发编程实战/">Java并发编程实战</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/FutureTask/">FutureTask</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p><font color="#E51508">委托是创建线程安全类的一个最有效策略：只需让现有的线程安全类管理所有的状态即可</font>。Java类库包含丰富的并发构建模块，如线程安全容器以及各种用于协调多个相互协作的线程的同步工具类。<br><a id="more"></a></p>
<h3 id="1-同步容器"><a href="#1-同步容器" class="headerlink" title="1. 同步容器"></a>1. 同步容器</h3><p>同步容器的方式是：将它们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能访问容器的状态，因此同步容器类是线程安全的。</p>
<p>同步容器类是通过其自身的锁来保护其状态访问，如果在某些情况下需要额外的客户端加锁来保护复合操作：如迭代或者条件运算（若没有则添加），可以通过获得容器类的锁，在客户端构造原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在客户端加锁可以解决不可靠的迭代问题，但会导致在迭代期间其他线程无法访问，降低了并发性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用size和get之间存在并发访问</span></span><br><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vector.size(); i++)&#123;</span><br><span class="line">        doSomething(vector.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步容器类的迭代器并没有考虑并发修改的问题，它的策略是“及时失败”，即当它们发现容器在迭代过程中被修改会及时抛出异常<code>ConcurrentModificationException</code></p>
<p>.<font color="Gray">集合类源码中有一个<code>modCount</code>计数，它表示当前集合被修改（新增或删除）的次数。在每次创建迭代器时会将迭代器中的<code>expectedModCount</code>置为<code>modCount</code>，如果在后面的迭代过程中发现这两个计数值不相等，则表示在创建完迭代器之后的迭代期间集合发生过改变，于是立即抛出异常。要注意的是，即使在单线程中，也可能抛出异常，如果在集合的迭代器迭代过程中，直接从容器中删除元素就会抛出这个异常。正确的做法是调用迭代器的删除方法<code>iterator.remove()</code>，它会同时修改<code>modCount</code>和<code>expectedModCount</code>，使它们保持一致</font>。</p>
<p>在多线程环境中要想避免这个异常，就必须在迭代过程中持有容器的锁。如果不想在迭代期间对容器加锁，一种替代的方法就是克隆容器，在副本上进行迭代，但克隆的过程中仍然要对容器加锁，这种方式的好坏取决于具体场景需求。    </p>
<p>另外在调用容器的<code>toString</code>，<code>hsahCode</code>，<code>equals</code>，<code>containsAll</code>，<code>removeAll</code>，<code>retainAll</code>等方法时，以及把容器作为参数的构造函数，都会间接的对容器进行迭代，因此要注意所有这些隐含的迭代操作都可能抛出异常。</p>
<h3 id="2-并发容器"><a href="#2-并发容器" class="headerlink" title="2. 并发容器"></a>2. 并发容器</h3><p>同步容器将所有对容器状态的访问都串行化，以实现线程安全，这种方法的代价是严重降低了并发性，因此，Java 5.0提供了多种并发容器来改进同步容器的性能。  </p>
<h4 id="2-1-ConcurrentHashMap"><a href="#2-1-ConcurrentHashMap" class="headerlink" title="2.1. ConcurrentHashMap"></a>2.1. ConcurrentHashMap</h4><p>同步容器在执行每个操作期间都持有一个锁。在一些操作中，比如<code>HashMap.get</code>或<code>List.contains</code>可能包含大量的工作，当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用<code>equals</code>，而<code>equals</code>本身也含有一定的计算量。在基于散列的容器中，如果hashCode不能很均匀地分布散列值，那么容器中的元素就不会均匀地分布在整个容器中。极端情况下，某个糟糕的散列函数可能会把一个散列表变成线性链表。当遍历很长的链表并且在某些或者全部元素上调用<code>equals</code>方法时，会花费相当长的时间，而这段时间内其他线程都不能访问该容器。</p>
<p>.<font color="Gray">可以参考源码分析：<a href="https://shanhm1991.github.io/2017/09/11/20170911/">https://shanhm1991.github.io/2017/09/11/20170911/</a> ，java 1.8之后，HashMap改成当链表长度超过一定阈值后尝试用红黑树来代替以降低遍历的深度</font>。</p>
<p>与<code>HashMap</code>一样，<code>ConcurrentHashMap</code>也是基于散列的Map，但它并不是让每个操作都在同一个锁上同步，使得每次只能有一个线程访问容器，而是用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为<font color="#E51508">分段锁</font>。这种机制可以提供更高的并发性和伸缩性，任意数量的读线程都可以并发的访问Map，执行读操作的线程与执行写操作的线程可以并发的访问Map，并且一定数量的写线程也可以并发地修改Map，这在并发访问环境下可以实现更高的吞吐量，而在单线程环境中只损失非常小的性能。 </p>
<p><code>ConcurrentHashMap</code>与其他并发容器一起增强了同步容器类，他们提供的迭代器具有弱一致性，不会抛出并发修改异常，也不需要在迭代过程中对容器加锁，弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造后将修改操作反映给容器。</p>
<p>尽管有这些改进，但仍有一些需要权衡的因素。对于一些需要在整个Map上进行计算的方法，比如<code>size()</code>和<code>isEmpty()</code>，办法是弱化这些方法的语义以反映容器的并发特性，因为返回的结果可能已经过期了，而只是一个近似值。但这是允许的，事实上<code>size()</code>和<code>isEmpty()</code>这样的方法在并发环境下的作用有限，因为它们的返回值总在不断变化，从而这些操作的需求也被弱化了，以换取对其他更重要操作的性能优化，如<code>get</code>，<code>put</code>，<code>containsKey</code>，<code>remove</code>等。  </p>
<p>另外，<font color="#E51508">由于ConcurrentHashMap不能被加锁来执行独占访问，因此无法使用客户端加锁来创建新的原子操作</font><font color="Gray">（由于我们获取不到想要的锁，因此客户端加锁也就失去意义）。</font>不过一些常见的复合操作，若没有则添加，若相等则去除，若相等则替换等，都已经实现成了原子操作，并声明在<code>ConcurrentMap</code>中。</p>
<h4 id="2-2-CopyOnWriteArrayList"><a href="#2-2-CopyOnWriteArrayList" class="headerlink" title="2.2. CopyOnWriteArrayList"></a>2.2. CopyOnWriteArrayList</h4><p><code>CopyOnWriteArrayList</code>用于替代同步List，在某些情况下可以提供更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。<font color="#E51508">写入时复制容器的线程安全性在于，只要正确地发布一个事实不可变对象，那么在访问该对象时就不再需要进一步的同步。</font>在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于数组的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改所带来的影响。    </p>
<p>但是，每当修改容器时都要复制底层数组，这需要一定的开销，尤其当容器的规模较大时。因此，仅当迭代操作远远多于修改操作时，才应该使用写入时复制容器。</p>
<h4 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3. Queue"></a>2.3. Queue</h4><p><code>Queue</code>用来临时保存一组等待处理的元素。常用的实现有<code>ConcurentLinkedQueue</code>，传统的先进先出队列。另外，阻塞队列<code>BlockingQueue</code>扩展了<code>Queue</code>，增加了可阻塞的插入和获取等操作。</p>
<p><strong>生产消费模式</strong>中，阻塞队列是常用的方式。其提供可阻塞的<code>put</code>/<code>take</code>方法，以及可定时的<code>offer</code>/<code>poll</code>方法。如果队列已经满了，那么<code>put</code>方法阻塞直到有空间可用；如果队列为空，那么<code>take</code>方法阻塞直到有元素可用；相对的<code>offer</code>和<code>poll</code>则及时返回一个失败状态。队列可以有界也可以无界，无界队列永远都不会充满，因此无界队列的<code>put</code>永远不会阻塞。    </p>
<p>生产消费模式将要完成的工作与执行工作两个过程分离开来，这样简化了开发过程，消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。一种最常见的生产者-消费者场景就是线程池与工作队列的组合，在<code>Executor</code>任务执行框架中体现了这种模式。</p>
<p>关于<code>BlockingQueue</code>有几种实现：  </p>
<ul>
<li><p><code>LinkedBlockigQueue</code>和<code>ArrayBlockingQueue</code>是FIFO队列，二者区别与<code>LinkedList</code>/<code>ArrayList</code>类似，但比同步<code>List</code>拥有更好的并发性；</p>
</li>
<li><p><code>PriorityBlockingQueue</code>是一个按优先级排序的队列，可以根据元素的自然顺序来比较元素，也可以使用<code>Comparator</code>来比较；</p>
</li>
<li><p><code>SynchronousQueue</code>并不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程等待着把元素加入或移出队列。这种区别就好像将文件直接交给同事还是将文件放到他的邮箱中希望他能尽快拿到文件。因为没有存储功能，因此<code>put</code>/<code>take</code>会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。因此仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。    </p>
</li>
</ul>
<h3 id="3-示例：桌面搜索"><a href="#3-示例：桌面搜索" class="headerlink" title="3. 示例：桌面搜索"></a>3. 示例：桌面搜索</h3><p>需求：扫描本地驱动器上的文件并建立索引以便随后进行搜索</p>
<figure class="highlight java"><figcaption><span class="caption">FileCrawler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCrawler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; fileQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            crawl(root);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        File[] entries = root.listFiles(fileFilter);</span><br><span class="line">        <span class="keyword">if</span>(entries != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File entry : entries)&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.isDirectory())&#123;</span><br><span class="line">                    crawl(entry);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!alreadyIndexed(entry))&#123;</span><br><span class="line">                    fileQueue.put(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(BlockingQueue&lt;File&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                indexFile(queue.take());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileCrawler</code>定义了生产者，在给定目录中搜索符合索引标准的文件，并将它们放入队列。<code>Indexer</code>定义了消费者，从队列中获取文件并对它们建立索引。因此，将遍历文件与建立索引分解成了独立操作，每个操作只需完成一个任务，并且阻塞队列将负责所有的控制流，这样每个功能的代码都更加简单清晰。    </p>
<p>.<font color="Gray">生产消费模式也是利用了线程封闭方法，生产者通过阻塞队列将非线程安全的可变对象的所有权移交给了消费者线程，即安全的发布给了消费者，自始至终对象都只是由单线程拥有，因此拥有该对象的线程可以对其进行任意修改</font>。</p>
<p>Java 6.0开始，增加了双端队列容器：<code>Deque</code>和<code>BlockingDeque</code>。它们分别对<code>Queue</code>和<code>BlockingQueue</code>做了扩展，可以在队列头或者队列尾进行高效插入和移除，具体实现有<code>ArrayDeque</code>和<code>LinkedBlockingDeque</code>。</p>
<p>双端队列适用于模式：<strong>工作密取</strong>，在生产消费模式中，所有消费者共享一个工作队列。而<font color="#E51508">在工作密取设计中，每个消费者都有自己的双端队列，如果一个消费者完成了自己队列中的工作，它可以从其他消费者的队列末尾获取工作。这样，密取模式比生产消费模式具有更高的可伸缩性，因为消费者线程不会在单个共享的任务队列上发生竞争</font>。</p>
<p>.<font color="Gray">这与上面的分段锁是一样的想法，即降低在同一个对象锁上面的竞争程度，另外，消费线程从尾部访问另一个队列，而不是从头部获取任务，也能降低队列上一定的竞争程度</font>。</p>
<p>密取模式非常适用于<strong>既是生产者也消费者问题</strong>，有时执行某个任务时可能导致更多的任务，比如网页爬虫，处理一个页面时发现更多的页面需要处理，又比如在垃圾回收阶段对堆进行标记问题。当消费线程发现新的任务时，它可以将其放到自己或其他消费线程的队列末尾。</p>
<h3 id="4-同步工具"><a href="#4-同步工具" class="headerlink" title="4. 同步工具"></a>4. 同步工具</h3><p>所有的同步工具类都包含一些特定的结构化属性，它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续还是等待。此外还提供了一些方法来对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。</p>
<h4 id="4-1-CountDownLatch"><a href="#4-1-CountDownLatch" class="headerlink" title="4.1. CountDownLatch"></a>4.1. CountDownLatch</h4><p>闭锁的作用相当于一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的，没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。但是，当闭锁到达结束状态后，将不会再改变状态，将永远保持打开状态。所以，闭锁一般用来确保某些活动直到其他活动都完成后才继续执行的场景。</p>
<p>.<font color="Gray">后面在同步工具类的设计中会介绍一种改进版的闭锁：阀门类，其状态可以重复打开和关闭</font>。</p>
<p><code>CountDownLatch</code>是一种灵活的闭锁实现，它包括一个计数器，初始化为一个正数，表示需要等待的事件数量。<code>countDown()</code>方法会递减计数器，表示有一个事件已经发生了，而<code>await()</code>方法一直等待直到计数器为零，表示直到所有等待的事件都已经发生。</p>
<figure class="highlight java"><figcaption><span class="caption">TestHarness</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, Runnable task)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException ignored)&#123;</span><br><span class="line">    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中<code>startGate</code>使主线程能够同时释放所有工作线程，确保所有的工作线程同时开始工作而达到并发的目的，<code>endGate</code>则使主线程能够等待最后一个线程执行完成。</p>
<h4 id="4-2-FutureTask"><a href="#4-2-FutureTask" class="headerlink" title="4.2. FutureTask"></a>4.2. FutureTask</h4><p><code>FutureTask</code>实现了<code>Future</code>语义，表示一种抽象的可生成结果的计算，通过<code>Callable</code>来实现。它可以处于三种状态：等待运行，正在运行，和运行完成。运行完成包括所有的可能方式，即正常结束、取消或异常失败，一旦进入完成状态，它将永远停在这个状态上。</p>
<p>.<font color="Gray">关于<code>FutureTask</code>源码分析，具体可以参考：<a href="https://shanhm1991.github.io/2018/04/05/20180405/">https://shanhm1991.github.io/2018/04/05/20180405/</a> </font>。</p>
<p><code>FutureTask</code>也可以用作闭锁，<code>Future.get()</code>的行为取决于任务的状态，如果任务已经完成，那么立即返回，否则将一直阻塞直到任务完成，然后返回结果或者抛出异常。显然<code>FutureTask</code>需要确保能够将计算结果从计算线程安全地发布给获取结果的线程。</p>
<p>通常，<code>FutureTask</code>用在<code>Executor</code>框架中表示异步任务，或者用于表示一些耗时计算，它可以将任务的执行与结果的获取分开。即可以先启动任务，然后在需要时再进行结果获取，如果完成了就直接获取，没有完成则进入等待，但也能省去一部分等待时间。</p>
<figure class="highlight java"><figcaption><span class="caption">PreLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// execute something</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3. Semaphore"></a>4.3. Semaphore</h4><p>信号量可以用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。<code>Semaphore</code>中管理着一组虚拟的许可，许可的数量可以通过构造函数来指定，然后在执行操作前首先获得许可，并在使用后释放。如果没有许可，那么<code>acquire</code>将阻塞直到有许可为止。</p>
<p>通常<code>Semaphore</code>可以用来实现一个可阻塞的资源池，比如构造一个固定长度的资源池，将<code>Semaphore</code>的计数值初始化为池的大小，然后从池中获取资源之前先<code>acquire</code>一个许可，并在将资源返回池中之后<code>release</code>一个许可，那么在当池为空或满时，资源的获取和释放将变成阻塞直到执行条件成立，而不是直接失败。</p>
<figure class="highlight java"><figcaption><span class="caption">BoundedSet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedSet</span><span class="params">(<span class="keyword">int</span> bound)</span></span>&#123;</span><br><span class="line">        <span class="comment">//虽然在许可的获取上使用了同步，但随后对set的操作依然存在竞争的风险</span></span><br><span class="line">        set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            added = set.add(t);</span><br><span class="line">            <span class="keyword">return</span> added;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">                sem.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span>(removed)&#123;</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-CyclicBarrier"><a href="#4-4-CyclicBarrier" class="headerlink" title="4.4. CyclicBarrier"></a>4.4. CyclicBarrier</h4><p>栅栏类似于闭锁，也是阻塞一组线程直到某个事件发生，它们的关键区别在于<font color="#E51508">闭锁用于等待事件，而栅栏用于等待其他线程</font>。</p>
<p>.<font color="Gray">换句话说，就是闭锁通常是让A事件线程等待其他B事件线程使某个条件成立，而栅栏是让一堆类似的事件T线程等待彼此到达一个约定的共同事件点</font>。</p>
<p>当线程到达栅栏位置时将调用<code>await</code>方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达，那么栅栏将打开，此时所有线程都将被释放，而栅栏将被重置，以便下次使用。</p>
<p>如果对<code>await()</code>调用超时或者在<code>await()</code>上阻塞的线程被中断，那么栅栏就认为是被打破了，所有阻塞在<code>await()</code>上线程都将终止并抛出<code>BrokenBarrierException</code>。如果成功地通过栅栏，那么<code>await()</code>将为每个线程返回一个唯一的到达索引，可以利用这些索引来选举一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。</p>
<p>一些场景中，某些步骤中的计算可以并行执行，但必须等待该步骤中的所有计算都完成后才可以进行下一步。例如，在n-body粒子模拟系统中，每个步骤都根据其他粒子的位置和属性来计算各个粒子的新位置。通过在两次步骤之间等待栅栏，可以确保在第K步中的所有更新操作都计算完毕，才进入第K+1步。  </p>
<ul>
<li>生命游戏中通过栅栏来计算细胞的自动化模拟：</li>
</ul>
<figure class="highlight java"><figcaption><span class="caption">CellularAutomata</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board board)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        mainBoard = board; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cpuCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        </span><br><span class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(cpuCount, <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mainBoard.commitNewValues();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        workers = <span class="keyword">new</span> Worker[cpuCount];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpuCount; i++)&#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(cpuCount, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">        &#125;</span><br><span class="line">        mainBoard.waitForConvergence();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.board = board;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line marked">            <span class="keyword">while</span>(!board.hasConvergence())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++)&#123;</span><br><span class="line">                        board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line marked">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CellularAutomata</code>将模拟过程并行化，如果为每个细胞元素分配一个线程是不合适的，过多的线程会导致协调上的开销从而降低性能。所以将细胞分成cpuCount份（由于没有IO过程，当线程数为cpu个数时，吞吐量最高），所以每个Worker分别计算总细胞数 / cpuCount个细胞。   </p>
<p>每次当<code>Worker</code>计算完一遍子问题中所有的细胞，便会到达栅栏等待，当所有<code>Worker</code>都到达时便一起通过栅栏，然后一起继续下一轮计算， 直到条件<code>hasConvergence()</code>成立，即问题收敛计算完毕。</p>
<p>另一种形式的栅栏<code>Exchanger</code>，称为<strong>两方栅栏</strong>，各方在栅栏位置上交换位置。当两方执行不对称的操作时，<code>Exchanger</code>会很有用。例如一个线程向缓存写数据，而另一个线程读取数据，它们可以使用<code>Exchanger</code>来汇合，并将满的缓存与空的缓存交换。关于交换时机的选择，当缓存被填满时由填充任务交换，当缓存为空时由清空任务交换，这样可以将交换的次数将至最低。但如果数据的到达不可预测，数据的处理将被延迟，所以可以在缓存被填充到一定程度并保持一定时间后也进行交换。</p>
<h3 id="5-示例：构建结果缓存"><a href="#5-示例：构建结果缓存" class="headerlink" title="5. 示例：构建结果缓存"></a>5. 示例：构建结果缓存</h3><p>接口<code>Computable</code>声明一个函数<code>compute</code>，输入类型为<code>A</code>，输出类型为<code>V</code></p>
<figure class="highlight java"><figcaption><span class="caption">Computable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//耗时运算</span></span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设它实现的是一些耗时运算，这里用装饰器来给它的实现增加一个缓存功能，用来记住之前的计算结果以便在接收到相同的输入时能直接返回结果</p>
<figure class="highlight java"><figcaption><span class="caption">Memorizer1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memorizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer1</code>使用<code>HashMap</code>来缓存结果，并使用同步来保证线程安全性，但存在明显的可伸缩性问题，当排队线程较多时甚至可能出现排队时间超过计算本身所需要的时间。</p>
<h4 id="5-1-改进：委托ConcurrentHashMap"><a href="#5-1-改进：委托ConcurrentHashMap" class="headerlink" title="5.1. 改进：委托ConcurrentHashMap"></a>5.1. 改进：委托ConcurrentHashMap</h4><figure class="highlight java"><figcaption><span class="caption">Memorizer2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memorizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer2</code>使用<code>ConcurrentHashMap</code>代替<code>HashMap</code>，有着更好的并发行为。但<code>Memorizer2</code>的<font color="#E51508">问题在于，如果某个线程启动了一个开销很大的计算，而其他线程并不知道这个计算正在进行，那么很可能会重复这个计算</font>。</p>
<h4 id="5-2-改进：缓存FutureTask"><a href="#5-2-改进：缓存FutureTask" class="headerlink" title="5.2. 改进：缓存FutureTask"></a>5.2. 改进：缓存FutureTask</h4><figure class="highlight java"><figcaption><span class="caption">Memorizer3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, FutureTask&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memorizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            f = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">            cache.put(arg, f);</span><br><span class="line">            f.run();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer2</code>是检查某个计算是否已经结束，而<code>Memorizer3</code>则是检查某个计算是否已经开始。因此它可以表现出更好的并发性，如果结果已经计算出来，将立即返回，如果有其他线程正在计算结果，那么新到的线程将直接等待这个已经开始的计算完成。</p>
<p>但它<font color="#E51508">仍然存在两个线程重复计算的可能，因为if的判断（先检查再执行）并非原子的，</font>可能多个线程同一时间到达<code>compute</code>方法，同时没有获取到<code>FutureTask</code>。</p>
<h4 id="5-3-改进：解决先判断后执行问题"><a href="#5-3-改进：解决先判断后执行问题" class="headerlink" title="5.3. 改进：解决先判断后执行问题"></a>5.3. 改进：解决先判断后执行问题</h4><figure class="highlight java"><figcaption><span class="caption">Memorizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memorizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;A, FutureTask&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memorizer</span><span class="params">(Computable&lt;A, V&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">            f = cache.putIfAbsent(arg, ft);</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123; <span class="comment">// f代表之前缓存的FutureTask，如果存在就直接丢弃新建的</span></span><br><span class="line">                f = ft;</span><br><span class="line">                f.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CancellationException e)&#123;</span><br><span class="line">            cache.remove(arg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Memorizer</code>使用原子操作<code>putIfAbsent</code>解决了先检查再执行的问题。但仍有问题需要考虑，当缓存的是<code>Future</code>而不是值时，将可能出现<font color="#E51508">缓存污染。</font>如果某个计算被取消或者失败，在获取结果时将知道计算过程被取消或者失败，那么应该将<code>Future</code>从缓存中移除，这样将来的计算才可能成功。另外<code>Memorizer</code>还需要考虑缓存的逾期和清理等问题。</p>
<p>.<font color="Gray">在自己实现的一个任务框架中有这样的场景：需要周期性的执行一批任务，每个任务有一个id，但是要求同一时刻，不可以存在相同任务id的任务同时运行。这里就涉及到需要判断缓存中<code>Future</code>状态的问题，仅仅委托<code>ConcurrentHashMap</code>也不能解决问题，考虑到提交任务是个消耗不大的操作，于是就妥协直接使用了同步</font>。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/spring-fom/blob/master/spring-fom/src/main/java/org/springframework/fom/</span><span class="caption">ScheduleContext.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,TimedFuture&lt;Result&lt;?&gt;&gt;&gt; submitMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitWithConflict</span><span class="params">(Collection&lt;? extends Task&lt;E&gt;&gt; tasks, ScheduleBatch&lt;E&gt; scheduleBatch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(submitMap)&#123;</span><br><span class="line">        Iterator&lt;? extends Task&lt;E&gt;&gt; it = tasks.iterator();</span><br><span class="line">        String taskId = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                Task&lt;E&gt; task = it.next();</span><br><span class="line">                taskId = task.getTaskId();</span><br><span class="line marked">                <span class="keyword">if</span> (isTaskAlive(taskId)) &#123;</span><br><span class="line marked">                    logger.warn(<span class="string">"task[&#123;&#125;] is still alive, create canceled."</span>, taskId);</span><br><span class="line marked">                    <span class="keyword">continue</span>;</span><br><span class="line marked">                &#125;</span><br><span class="line"></span><br><span class="line">                task.setScheduleBatch(scheduleBatch);</span><br><span class="line">                TimedFuture future = (TimedFuture)submit(task);</span><br><span class="line"></span><br><span class="line">                it.remove();</span><br><span class="line marked">                submitMap.put(taskId, future);    </span><br><span class="line">                submitFutures.add(future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"task[&#123;&#125;] submit rejected, and ignored task=&#123;&#125;"</span>, taskId, tasks, e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTaskAlive</span><span class="params">(String taskId)</span></span>&#123;</span><br><span class="line marked">    Future&lt;Result&lt;?&gt;&gt; future = submitMap.get(taskId);</span><br><span class="line marked">    <span class="keyword">return</span> future != <span class="keyword">null</span> &amp;&amp; !future.isDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><strong>参考：</strong> </p>
<ol>
<li>Copyright&nbsp;&copy;《java并发编程实战》</li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2019/01/05/20190105/">
		    《Java并发编程实战》 任务的执行
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2019/01/03/20190103/">
		    《Java并发编程实战》 线程安全类的设计
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/Java并发编程实战/">Java并发编程实战</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/FutureTask/">FutureTask</a>
  </div>


         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#java_ul").click(function(){ $("#java_li").toggle(); });
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
    $("#db_ul").click(function(){ $("#db_li").toggle(); });		
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-同步容器"><span class="toc-text">1. 同步容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-并发容器"><span class="toc-text">2. 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-ConcurrentHashMap"><span class="toc-text">2.1. ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-CopyOnWriteArrayList"><span class="toc-text">2.2. CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Queue"><span class="toc-text">2.3. Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-示例：桌面搜索"><span class="toc-text">3. 示例：桌面搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-同步工具"><span class="toc-text">4. 同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-CountDownLatch"><span class="toc-text">4.1. CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-FutureTask"><span class="toc-text">4.2. FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Semaphore"><span class="toc-text">4.3. Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-CyclicBarrier"><span class="toc-text">4.4. CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-示例：构建结果缓存"><span class="toc-text">5. 示例：构建结果缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-改进：委托ConcurrentHashMap"><span class="toc-text">5.1. 改进：委托ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-改进：缓存FutureTask"><span class="toc-text">5.2. 改进：缓存FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-改进：解决先判断后执行问题"><span class="toc-text">5.3. 改进：解决先判断后执行问题</span></a></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2023 &nbsp;&nbsp; @by shanhm1991 &nbsp;&nbsp; @version 1.0.0
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
