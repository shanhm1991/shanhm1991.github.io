<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>《java并发编程实战》. 笔记十（同步工具类的设计） | Essay</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="引言创建状态依赖类的最简单方法通常是在类库中现有状态依赖类的基础上进行构造。如果类库中没有提供你需要的功能，可以使用java语言和类库提供的底层机制来构造自己的同步机制，
包括内置的条件队列、显示的Condition对象以及AbstractQueuedSynchronizer框架。
在单线程程序中调用方法时，如果基于某个状态的前提条件未得到满足，那么这个条件永远无法成真。而在并发程序中，基于状态的条件可能会由于其他线程的操作而改变。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《java并发编程实战》. 笔记十（同步工具类的设计）"/>
  <meta property="og:site_name" content="Essay"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Essay" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Essay</a></h1>
  <span style="color:#ADA5A0; height:20px;line-height:30px;">不人云亦云，不断章取义</span>
  <h2><font style="color: #999;">articles:  86 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20190110" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-01-09T16:00:00.000Z"><a href="/2019/01/10/20190110/">2019-01-10</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        《java并发编程实战》. 笔记十（同步工具类的设计）
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <font style="color: #999;"> words: 5.7k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 22min</font>
   
   
  
  <div class="categories">
    <a href="/categories/读书笔记/">读书笔记</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/条件队列/">条件队列</a>   <a href="/tags/AQS/">AQS</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>创建状态依赖类的最简单方法通常是在类库中现有状态依赖类的基础上进行构造。如果类库中没有提供你需要的功能，可以使用java语言和类库提供的底层机制来构造自己的同步机制，
包括内置的条件队列、显示的<code>Condition</code>对象以及<code>AbstractQueuedSynchronizer</code>框架。</p>
<p><font color="#E51508">在单线程程序中调用方法时，如果基于某个状态的前提条件未得到满足，那么这个条件永远无法成真。而在并发程序中，基于状态的条件可能会由于其他线程的操作而改变。</font></p>
<a id="more"></a>

<h3 id="1-可阻塞的状态依赖操作"><a href="#1-可阻塞的状态依赖操作" class="headerlink" title="1. 可阻塞的状态依赖操作"></a>1. 可阻塞的状态依赖操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">acquire lock on object state</span><br><span class="line"><span class="keyword">while</span>(precondition does not hold)&#123;</span><br><span class="line">    release lock</span><br><span class="line">    wait until precondition hold</span><br><span class="line">    operation fail <span class="keyword">if</span> interrupted or timeout expires</span><br><span class="line">    reacquire lock</span><br><span class="line">&#125;</span><br><span class="line">perform action</span><br><span class="line">release lock</span><br></pre></td></tr></table></figure>

<p>这种加锁模式有些不寻常，因为锁是在操作的执行过程中被释放与重新获取的。<font color="#E51508">构成前提条件的状态变量必须由对象的锁来保护，
从而使它们在测试前提条件的同时保持不变。</font>如果前提条件尚未满足，就必须释放锁，以便其他线程可以修改对象的状态，否则前提条件永远无法成真。而再次测试前提条件之前，必须重新获得锁。</p>
<h3 id="2-示例：实现一个有界缓存"><a href="#2-示例：实现一个有界缓存" class="headerlink" title="2. 示例：实现一个有界缓存"></a>2. 示例：实现一个有界缓存</h3><p>先基于数组实现一个循环缓存<code>BaseBoundedBuffer</code>，其缓存状态<code>buf</code>，<code>tail</code>，<code>head</code>，<code>count</code>均由内置锁来保护，并对子类隐藏。<code>isFull()</code>和<code>isEmpty()</code>用来提供同步的条件检查，<code>doput</code>和<code>dotake</code>方法用来提供同步的<code>put</code>和<code>take</code>操作，
以便我们可以在子类中执行操作前先检查条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doput</span><span class="params">(V v)</span></span>&#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span>(++tail == buf.length)&#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">dotake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(++head == buf.length)&#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-将前提条件的失败反馈给调用者"><a href="#2-1-将前提条件的失败反馈给调用者" class="headerlink" title="2.1. 将前提条件的失败反馈给调用者"></a>2.1. 将前提条件的失败反馈给调用者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrumpyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GrumpyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> BufferFullException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferFullException();</span><br><span class="line">        &#125;</span><br><span class="line">        doput(v);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> BufferFullException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferFullException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dotake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于put和take中采用先检查再运行的策略，所以尽管父类中的检查和执行两个操作都已经使用同步，但在子类操作上依然需要同步<font color="Gray">（显然，这里是利用了锁的可重入性，
子类中相当于把父类中两个动作的锁合并成了一个锁，以便保证两个动作是一个整体）</font>。</p>
<p>虽然这样直接将前提条件失败转化为异常抛给调用者处理的实现方式很简单，但是并不能抵消在使用时的复杂性。调用者必须做好捕获异常的准备，并且每次缓存操作时都需要重试。</p>
<h4 id="2-2-示例改进：通过轮询与休眠来实现简单的阻塞"><a href="#2-2-示例改进：通过轮询与休眠来实现简单的阻塞" class="headerlink" title="2.2. 示例改进：通过轮询与休眠来实现简单的阻塞"></a>2.2. 示例改进：通过轮询与休眠来实现简单的阻塞</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isFull())&#123;</span><br><span class="line">                    doput(v);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> dotake();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SleepyBoundedBuffer</code>通过轮询的方式来进行重试。如果检测成功，则执行操作，而如果检测失败，则休眠一段时间，以便其他线程能够访问缓存，
当醒来时再进行尝试。<font color="Gray">要注意的是，检测和执行需要通过锁来保护，但是休眠的时候不可以持有锁。以前经常会提到sleep与wait的区别，这里就能体现出来了，线程在sleep休眠时不会释放它持有的锁，因此将会造成死锁，
使其他线程永远获取不到锁来使条件检测变为真。</font></p>
<p><code>SleepyBoundedBuffer</code>简化了对缓存的使用，调用者无须处理失败和重试，但调用者需要处理<code>InterruptedException</code>，<code>SleepyBoundedBuffer</code>提供了一个取消策略，当等待条件非真而休眠时，如果中断，则抛出<code>InterruptedException</code>。
另外，<code>SleepyBoundedBuffer</code>需要选择一个合适的休眠时间，以便在响应性与cpu使用率之间达到平衡，比如休眠越短，则响应性越高，但cpu消耗也越高。</p>
<h3 id="3-条件队列"><a href="#3-条件队列" class="headerlink" title="3. 条件队列"></a>3. 条件队列</h3><p>通过轮询与休眠来实现阻塞操作的方式需要付出大量的努力，如果存在某种挂起线程的方法<font color="Gray">（并且挂起前释放锁）</font>，
并且这种方法能够确保当条件为真时线程立即醒来<font color="Gray">（响应性）</font>，那么将极大地简化实现工作，而这正是条件队列实现的功能。</p>
<p>条件队列的名字来源于：它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。因此，条件队列中的元素是一个个正在等待相关条件的线程，而传统队列中的元素是一个个数据。</p>
<p>正如每个java对象都可以作为一个锁，每个对象同样可以作为一个条件队列，我们称为内置条件队列，并且<code>Object</code>中的<code>wait</code>，<code>notify</code>，<code>notifyAll</code>方法就构成了内部条件队列的API。
<code>Object.wait</code>会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。当挂起的线程醒来时，他将在返回前重新获得锁。</p>
<h4 id="3-1-示例改进：使用条件队列"><a href="#3-1-示例改进：使用条件队列" class="headerlink" title="3.1. 示例改进：使用条件队列"></a>3.1. 示例改进：使用条件队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isFull())&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        doput(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isEmpty())&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        V v = dotake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BoundedBuffer</code>不仅简单易用，而且实现了明晰的状态依赖性管理。与使用休眠的<code>SleepyBoundedBuffer</code>相比，条件队列并没有改变原来的语义，它只是在cpu效率、上下文切换开销、响应性等方面进行了优化。</p>
<h4 id="3-2-示例改进：优化条件队列的使用"><a href="#3-2-示例改进：优化条件队列的使用" class="headerlink" title="3.2. 示例改进：优化条件队列的使用"></a>3.2. 示例改进：优化条件队列的使用</h4><p><code>BoundedBuffer</code>中，<code>put</code>和<code>take</code>采用的通知机制是保守的，每当将一个对象放入缓存或者从缓存中移走一个对象时，就执行一次通知。实际上，仅当缓存从空变为非空或者从满变为非满，而且当<code>put</code>或<code>take</code>影响到这些状态转换时，
才需要发出通知唤醒线程，称为<strong>条件通知</strong>。虽然可以提升性能，但很难被正确的实现，在使用时需要谨慎。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer2</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BoundedBuffer2</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isFull())&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> wasEmpty = isEmpty();</span><br><span class="line">    doput(v);</span><br><span class="line">    <span class="keyword">if</span>(wasEmpty)&#123;</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(isEmpty())&#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> wasFull = isFull();</span><br><span class="line">    V v = dotake();</span><br><span class="line">    <span class="keyword">if</span>(wasFull)&#123;</span><br><span class="line">      notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-条件谓词"><a href="#4-条件谓词" class="headerlink" title="4. 条件谓词"></a>4. 条件谓词</h3><p>要想正确的使用条件队列，关键是找出对象在哪个条件谓词上等待。条件谓词是使某个操作成为状态依赖操作的前提，比如在<code>BoundedBuffer</code>中，<code>take</code>的条件谓词是缓存非空，而<code>put</code>的条件谓词是缓存非满。
因此，条件谓词通常是由类中各个状态变量构成的表达式。</p>
<p><font color="#E51508">在条件等待中存在一种重要的三元关系，包括加锁、wait方法和一个条件谓词。在条件谓词中包含多个状态变量，这些状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁，
并且锁对象与条件队列对象（即调用wait和notify等方法所在的对象）必须是同一个对象。</font></p>
<h3 id="5-示例：阀门类"><a href="#5-示例：阀门类" class="headerlink" title="5. 示例：阀门类"></a>5. 示例：阀门类</h3><p>在<a href="https://shanhm1991.github.io/2019/01/04/20190104/">线程安全性的委托以及常见的线程安全容器和工具</a>中曾介绍过闭锁的使用。
闭锁有两种状态：关闭和打开，但是一旦打开了就无法再使用了，借助条件队列，我们可以设计一个可以重新关闭的闭锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//条件谓词 isOpen || generation &gt; n</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> generation;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++generation;</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrivalGeneration = generation;</span><br><span class="line">        <span class="keyword">while</span>(!isOpen &amp;&amp; arrivalGeneration == generation)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadGate</code>可以打开和关闭阀门，并提供一个<code>await</code>方法，该方法能一直阻塞直到阀门打开。在<code>await</code>中使用的条件谓词比测试<code>isOpen</code>复杂得多，这是必需的，因为<font color="#E51508">如果当阀门打开时有N个线程正在等待它，
那么这些线程都应该允许通过。</font>然而，如果阀门在打开后又非常快速的关闭了，并且<code>await</code>方法只检查<code>isOpen</code>，那么所有线程都可能无法释放。因此，每次阀门打开时，递增一个<code>generation</code>计数器，如果阀门现在是打开的，
或者阀门自从该线程到达后就一直是打开的，那么线程都可以通过<code>await</code>。</p>
<p><font color="#E51508">await()中，arrivalGeneration表示线程到达阀门被阻塞挂起时阀门的打开次数。当线程收到通知最终被唤醒并获取锁后，如果阀门状态是打开的那么直接通过，否则再看一下当前阀门的打开次数generation，
并与被挂起时阀门的打开次数进行比较。如果不等，则表示线程在被挂起后，阀门被打开过，虽然当前阀门状态又是关闭的，所以在阀门打开之前就已经阻塞的线程应该通过。所以通过比较arrivalGeneration与generation，
确保了每个在wait上阻塞的线程在收到阀门打开通知后，最终都能通过阀门，即便在发出通知后立马又重新关闭。</font></p>
<h3 id="6-过早唤醒问题"><a href="#6-过早唤醒问题" class="headerlink" title="6. 过早唤醒问题"></a>6. 过早唤醒问题</h3><p>内置条件队列可以与多个条件谓词一起使用，当一个线程由于调用<code>notifyAll</code>而醒来时，并不意味着该线程正在等待的条件谓词以已经变成真了。举个例子，如果面包机与咖啡机如果共用一个铃声，
那么当响铃后，你并不能确定就是面包烤好了。<font color="Gray">在BoundedBuffer中，条件队列就与缓存非空和缓存非满两个条件谓词相关，设想当一个线程put成功之后使缓存满了，它希望唤醒的是在take上等待的线程，
但是它同时会唤醒在put上等待的其他线程，而所有这些线程将一起重新竞争锁，如果put上的线程竞争成功了，它又将重新挂起。当竞争非常激烈时，将会导致很大的上下文切换开销。</font></p>
<p>另一种情况是，在发出通知的线程调用<code>notifyAll</code>时，条件谓词可能已经变成真，但在重新获取获取锁时又再次变成假。因为在线程被唤醒到<code>wait</code>重新获取锁这段时间里，可能有其他线程已经获取了这个锁，
并修改了条件谓词的状态。<font color="Gray">类似的，竞争失败的线程又会重新挂起，而导致不必要的上下文切换开销。notify是可以从等待队列中只选一个线程进行唤醒，但在BoundedBuffer中行不通，因为共用了条件谓词，
可能导致通知丢失，比如put的线程希望唤醒一个take上阻塞的线程，却被另一个在put上阻塞的线程收到了，而收到唤醒的put线程又只能重新挂起。最后只能等待重新再来一个新的请求take操作的线程来解除这个困境。</font></p>
<p>所以，内置条件队列存在一些缺陷。因为每个内置锁都只能有一个相关联的条件队列，因而在像<code>BoundedBuffer</code>这种类中，<font color="#E51508">多个线程只能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下暴露条件队列对象。</font></p>
<h3 id="7-显示地Condition对象"><a href="#7-显示地Condition对象" class="headerlink" title="7. 显示地Condition对象"></a>7. 显示地Condition对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeOut)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如<code>Lock</code>比内置锁提供了更丰富的功能，<font color="#E51508">Condition同样也比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待队列、条件等待可以是可中断或不可中断、
基于时限的等待，以及公平的或非公平的队列操作。</font>每个<code>Lock</code>可以有任意数量的<code>Condition</code>对象，它们继承了<code>Lock</code>对象的公平性。</p>
<h4 id="7-1-示例改进：使用Condition"><a href="#7-1-示例改进：使用Condition" class="headerlink" title="7.1. 示例改进：使用Condition"></a>7.1. 示例改进：使用Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBoundedBuffer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[])<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻塞直到notFull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count == items.length)&#123;</span><br><span class="line">                notFull.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = x;</span><br><span class="line">            <span class="keyword">if</span>(++tail == items.length)&#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻塞直到notEmpty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span>  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T t = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(++head == items.length)&#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConditionBoundedBuffer</code>的行为与<code>BoundedBuffer</code>相同，但分析使用多个<code>Condition</code>的类，比分析使用单一内部队列加多个条件谓词的类简单得多。通过将两个条件谓词分开并放到两个等待线程集中，
<code>Condition</code>使其更容易满足单次通知的需求。<code>signal</code>比<code>signalAll</code>更高效<font color="Gray">（类似的notify与notifyAll，但在内置条件队列上，通常notify不适用，
比如BoundedBuffer）</font>，它能极大地减少在每次缓存操作中发生的上下文切换与锁请求的次数。与内置锁和条件队列一样，当使用显示的<code>Lock</code>和<code>Condition</code>时，也必须满足锁、
条件谓词和条件变量之间的三元关系。在条件谓词中包含的变量必须由<code>Lock</code>来保护，并且在检查条件谓词以及调用<code>await</code>和<code>signal</code>时，必须持有<code>Lock</code>对象。</p>
<h3 id="8-AbstractQueuedSynchronizer"><a href="#8-AbstractQueuedSynchronizer" class="headerlink" title="8. AbstractQueuedSynchronizer"></a>8. AbstractQueuedSynchronizer</h3><p>在<code>ReentrantLock</code>和<code>Semaphore</code>这两个接口之间存在许多共同点，这两个类都可以用做一个阀门，即每次只允许一定数量的线程通过。或许我们会认为<code>Semaphore</code>是基于<code>ReentrantLock</code>实现的，
或者认为<code>ReentrantLock</code>实际上是带有一个许可的<code>Semaphore</code>。这些实现方式都是可行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreOnLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition permitAvailable = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> permits;</span><br><span class="line">    </span><br><span class="line">    SemaphoreOnLock(<span class="keyword">int</span> permits)&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.permits = permits;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(permits &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                permitAvailable.await();</span><br><span class="line">            &#125;</span><br><span class="line">            --permits;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ++permits;</span><br><span class="line">            permitAvailable.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但事实上，它们的实现都使用了一个共同的基类，<code>AbstractQueuedSynchronizer</code>，这个类也是其他许多同步类的基类。AQS是一个用于构建锁和同步器的框架，不仅是<code>ReentrantLock</code>和<code>Semaphore</code>，
还包括<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code>、<code>SynchronousQueue</code>和<code>FutureTask</code>。在<code>SemaphoreOnLock</code>中，获取许可的操作可能在两个时刻阻塞：当锁保护信号量状态时，以及当许可不可用时。
在基于AQS构建的同步器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。AQS在设计时充分考虑了可伸缩性，java.util.concurrent中所有基于AQS构建的同步器都能获得这个优势。</p>
<p><font color="#E51508">如果一个类想成为状态依赖的类，那么它必须拥有一些状态。AQS负责管理同步器类中的状态，它管理了一个整数状态信息，可以通过getState,setState以及compareAndSetState等protected类型方法来进行操作，
这个整数可以用于表示任意状态。</font>在ReentrantLock中，它用来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它来表示任务的状态。在同步器类中还可以自行管理一些额外的状态变量，
如ReentrantLock保存了锁的当前所有者信息，这样就能区分某个获取操作是重入还是竞争的。<font color="#E51508">事实上，java.util.concurrent中的所有同步器类都没有直接扩展AQS，而是都将它们的相应功能委托给私有的AQS子类来实现。</font></p>
<ul>
<li>AQS中获取操作和释放操作的标准形式:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(当前状态不允许获取操作)&#123;</span><br><span class="line">            <span class="keyword">if</span>(需要阻塞获取请求)&#123;</span><br><span class="line">                如果当前线程不在队列中，则将其插入队列</span><br><span class="line">                阻塞当前线程</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                返回失败</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        可能更新同步器的状态</span><br><span class="line">        如果线程位于队列中，则将其移出队列</span><br><span class="line">        返回成功</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        更新同步器的状态</span><br><span class="line">        <span class="keyword">if</span>(新的状态允许某个被阻塞的线程获取成功)&#123;</span><br><span class="line">            解除队列中一个或多个线程的阻塞状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="9-示例：一个简单的闭锁"><a href="#9-示例：一个简单的闭锁" class="headerlink" title="9. 示例：一个简单的闭锁"></a>9. 示例：一个简单的闭锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShotLatch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignored)</span></span>&#123;</span><br><span class="line">            <span class="comment">//如果闭锁是开的（state == 1），那么操作成功，否则失败</span></span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">1</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignored)</span></span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>); <span class="comment">//打开闭锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>OneShotLatch</code>中，AQS状态用来表示闭锁状态：关闭(0)或者打开(1)。<code>await</code>方法调用AQS的<code>acquireSharedInterruptibly</code>，然后接着调用<code>tryAcquireShared</code>。在<code>tryAcquireShared</code>的实现中必须返回一个值来表示该获取操作能否执行。
如果之前已经打开了闭锁，那么<code>tryAcquireShared</code>将返回成功并允许线程通过，否则就会返回一个表示获取操作失败的值。<code>acquireSharedInterruptibly</code>处理失败的方式，是把这个线程放入等待线程队列中。
类似的，<code>signal</code>将调用<code>releaseShared</code>，接下来又会调用<code>tryReleaseShared</code>。在<code>tryReleaseShared</code>中将无条件地把闭锁的状态设置为打开，表示该同步类处于完全释放的状态。</p>
<h3 id="10-java-util-concurrent同步器类中的AQS"><a href="#10-java-util-concurrent同步器类中的AQS" class="headerlink" title="10. java.util.concurrent同步器类中的AQS"></a>10. java.util.concurrent同步器类中的AQS</h3><h4 id="10-1-ReentrantLock"><a href="#10-1-ReentrantLock" class="headerlink" title="10.1. ReentrantLock"></a>10.1. ReentrantLock</h4><p><code>ReentrantLock</code>只支持独占方式的获取操作，因此它实现了<code>tryAcquire</code>、<code>tryRelease</code>和<code>isHeldExclusively</code>。<code>ReentrantLock</code>将同步状态用于保存锁获取操作的次数，并且维护一个<code>owner</code>变量来保存当前所有者线程的标识符，
只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。在<code>tryRelease</code>中检查<code>owner</code>域，从而确保当前线程在执行<code>unlock</code>操作之前已经获取了锁，在<code>tryAcquire</code>中将使用这个域来区分获取操作是重入还是竞争的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignored)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">            owner = current;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current == owner)&#123;</span><br><span class="line">        setState(c+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个线程尝试获取锁时，<code>tryAcquire</code>将首先检查锁的状态。如果锁未被持有，那么它将尝试更新锁的状态以表示锁已经被持有。由于状态可能在检查后被立即修改，因此<code>tryAcquire</code>使用<code>compareAndSetState</code>来更新状态。
如果锁状态表明它已经被持有，并且如果当前线程是锁的持有者，那么获取计数会递增。如果当前线程不是锁的拥有者，那么获取操作将失败。</p>
<h4 id="10-2-Semaphore与CountDownLatch"><a href="#10-2-Semaphore与CountDownLatch" class="headerlink" title="10.2. Semaphore与CountDownLatch"></a>10.2. Semaphore与CountDownLatch</h4><p>Semaphore将AQS的同步状态用于保存当前可用许可的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span>(remaining &lt; <span class="number">0</span> || compareAndSetState(available,remaining))&#123;</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> release)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = getState();</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(p,p + release))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryAcquireShared</code>方法首先计算剩余许可的数量，如果没有足够的许可，那么会返回一个值表示获取操作失败。如果还有剩余的许可，那么<code>tryAcquireShared</code>会通过<code>compareAndSetState</code>方式来降低许可的计数。
如果这个操作成功，那么将返回一个值表示获取操作的成功。<br>当没有足够的许可，或者当<code>tryAcquireShared</code>可以通过原子方式来更新许可计数以响应获取操作时，<code>while</code>循环将终止。虽然<code>compareAndSetState</code>的调用可能由于与另一个线程发生竞争而失败，并使其重新尝试，
但在经过了一定次数的重试操作以后，在这两个结束条件中有一个会变为真。</p>
<p><code>CountDownLatch</code>使用AQS的方式很相似，在同步状态中保存的是当前的计数值。<code>countDown</code>方法调用<code>release</code>，从而导致计数值递减，并且当计数值为零时，解除所有等待线程的阻塞。
<code>await</code>调用<code>acquire</code>，当计数器为零时，<code>acquire</code>将立即返回，否则将阻塞。</p>
<h4 id="10-3-FutureTask"><a href="#10-3-FutureTask" class="headerlink" title="10.3. FutureTask"></a>10.3. FutureTask</h4><p><font color="#E51508">Future.get()的语义非常类似于闭锁：如果发生了某个事件，那么线程就可以恢复执行，否则这些线程将停留在队列中并直到该事件发生。</font></p>
<p>在<code>FutureTask</code>中，AQS同步状态被用来保存任务的状态，如：正在执行、已完成或已取消。另外，<code>FutureTask</code>还维护一些额外的状态变量，用来保存计算结果或者抛出的异常，
以及一个指向正在执行计算任务的线程的引用，因此如果任务取消，该可以中断该线程。</p>
<h4 id="10-4-ReentrantReadWriteLock"><a href="#10-4-ReentrantReadWriteLock" class="headerlink" title="10.4. ReentrantReadWriteLock"></a>10.4. ReentrantReadWriteLock</h4><p><code>ReadWritelock</code>接口表示存在两个锁：一个读取锁和一个写入锁，但在基于AQS实现的<code>ReentrantReadWriteLock</code>中，单个AQS子类将同时管理读取加锁和写入加锁。<code>ReentrantReadWriteLock</code>使用了一个16位的状态来表示写入锁的计数，
并且使用了另一个16位的状态来表示读取锁的计数。在读取锁上的操作将使用共享的获取方法与释放方法，在写入锁上的操作将使用独占的获取方法与释放方法。<br>AQS在内部维护一个等待线程队列，其中记录了某个线程请求的是独占访问还是共享访问。在<code>ReentrantReadWriteLock</code>中，当锁可用时，如果位于队列头部的线程执行写入操作，那么线程就会得到这个锁，
如果位于队列头部的线程执行读取访问，那么队列中在第一个写入线程之前的所有线程都将获得这个锁。</p>
<p><br><strong>参考：</strong> </p>
<ol>
<li>Copyright&nbsp;&copy;《java并发编程实战》</li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2019/01/11/20190111/">
		    《java并发编程实战》. 笔记十一（非阻塞同步机制）
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2019/01/09/20190109/">
		    《java并发编程实战》. 笔记九（显式锁的使用）
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/读书笔记/">读书笔记</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/条件队列/">条件队列</a>   <a href="/tags/AQS/">AQS</a>
  </div>


        
  <div class="addthis addthis_toolbox addthis_default_style">
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

  

  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-可阻塞的状态依赖操作"><span class="toc-text">1. 可阻塞的状态依赖操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-示例：实现一个有界缓存"><span class="toc-text">2. 示例：实现一个有界缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-将前提条件的失败反馈给调用者"><span class="toc-text">2.1. 将前提条件的失败反馈给调用者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-示例改进：通过轮询与休眠来实现简单的阻塞"><span class="toc-text">2.2. 示例改进：通过轮询与休眠来实现简单的阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-条件队列"><span class="toc-text">3. 条件队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-示例改进：使用条件队列"><span class="toc-text">3.1. 示例改进：使用条件队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-示例改进：优化条件队列的使用"><span class="toc-text">3.2. 示例改进：优化条件队列的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-条件谓词"><span class="toc-text">4. 条件谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-示例：阀门类"><span class="toc-text">5. 示例：阀门类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-过早唤醒问题"><span class="toc-text">6. 过早唤醒问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-显示地Condition对象"><span class="toc-text">7. 显示地Condition对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-示例改进：使用Condition"><span class="toc-text">7.1. 示例改进：使用Condition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-AbstractQueuedSynchronizer"><span class="toc-text">8. AbstractQueuedSynchronizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-示例：一个简单的闭锁"><span class="toc-text">9. 示例：一个简单的闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-java-util-concurrent同步器类中的AQS"><span class="toc-text">10. java.util.concurrent同步器类中的AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-ReentrantLock"><span class="toc-text">10.1. ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-Semaphore与CountDownLatch"><span class="toc-text">10.2. Semaphore与CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-FutureTask"><span class="toc-text">10.3. FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-ReentrantReadWriteLock"><span class="toc-text">10.4. ReentrantReadWriteLock</span></a></li></ol></li></ol></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2021 shanhm1991 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
