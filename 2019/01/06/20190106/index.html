<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>《Java并发编程实战》 任务的取消 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="如果外部代码能在某个操作正常完成之前将其置入完成状态，那么这个操作就可以称为可取消的，行为良好的软件都应该能很完善地处理失败、关闭和取消等过程。 一个可取消的任务必须拥有取消策略，在这个策略中定义：

其他代码如何请求取消该任务；
任务在何时检查是否已经请求了取消；
在响应取消请求时应该执行哪些操作；

Java中并没有提供任何机制来安全地终止线程，但它提供了一种协作机制，即通过设置某个已请求取消的标志，然后任务执行过程中定期地查看该标志，如果设置了，那么任务提前结束。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《Java并发编程实战》 任务的取消"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  108 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20190106" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2019-01-05T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2019/01/06/20190106/" style="color: #736f6f;">2019-01-06</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        《Java并发编程实战》 任务的取消
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 7.9k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 31min</font>
   
   
  
  <div class="categories">
    <a href="/categories/Java并发编程实战/">Java并发编程实战</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/Future/">Future</a>   <a href="/tags/ThreadPool/">ThreadPool</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>如果外部代码能在某个操作正常完成之前将其置入完成状态，那么这个操作就可以称为可取消的，<font color="#E51508">行为良好的软件都应该能很完善地处理失败、关闭和取消等过程。</font> 一个可取消的任务必须拥有取消策略，在这个策略中定义：</p>
<ul>
<li>其他代码如何请求取消该任务；</li>
<li>任务在何时检查是否已经请求了取消；</li>
<li>在响应取消请求时应该执行哪些操作；</li>
</ul>
<p>Java中<font color="#E51508">并没有提供任何机制来安全地终止线程，但它提供了一种协作机制，即通过设置某个已请求取消的标志，然后任务执行过程中定期地查看该标志，如果设置了，那么任务提前结束</font>。</p>
<a id="more"></a>
<h3 id="1-自定义取消"><a href="#1-自定义取消" class="headerlink" title="1. 自定义取消"></a>1. 自定义取消</h3><h4 id="1-1-示例：取消素数生成器"><a href="#1-1-示例：取消素数生成器" class="headerlink" title="1.1. 示例：取消素数生成器"></a>1.1. 示例：取消素数生成器</h4><figure class="highlight java"><figcaption><span class="caption">PrimeGenerator</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PrimeGenerator</code>使用一种简单的取消策略：设定一个取消标志，如果被置位了，则说明收到了取消请求。然后在每次搜索素数前首先检查是否存在取消请求，如果存在则取消。因此，客户端可以通过调用<code>cancel</code>来请求取消，比如：</p>
<figure class="highlight java"><figcaption><span class="caption">secondPrimes</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;BigInteger&gt; <span class="title">secondPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">    <span class="keyword">new</span> Thread(generator).start();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        generator.cancel(); <span class="comment">// 保证即使sleep被中断，也能取消素数生成器的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generator.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PrimeGenerator</code>的取消机制最终会使得素数生成器的任务退出，但在退出的过程中需要花费一定的时间。比如示例中通常不会刚好在运行1秒钟后停止，因为在请求取消的时刻和下一次检查之间存在着延迟。更严重的，<font color="#E51508">如果使用这种方法的任务调用了一个阻塞方法，那么任务可能永远不会检查取消标志，因此永远不会结束</font>。</p>
<figure class="highlight java"><figcaption><span class="caption">BrokenPrimeProducer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span>(!cancelled)&#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BrokenPrimeProducer</code>中如果生产的速度超过了消费者的处理速度，队列将被填满，<code>put</code>方法将会阻塞。当阻塞在<code>put</code>方法上时，如果消费者停止消费并希望取消生产者任务，它会调用<code>cancel()</code>方法来设置<code>cancelled</code>标志。但此时已经无法从阻塞的<code>put</code>方法中恢复过来，因此将永远不能检查这个标志。</p>
<figure class="highlight java"><figcaption><span class="caption">consumer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumePrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;BigInteger&gt; primes = <span class="keyword">new</span> LinkedBlockingQueue&lt;BigInteger&gt;();</span><br><span class="line">	</span><br><span class="line">    BrokenPrimeProducer producer = <span class="keyword">new</span> BrokenPrimeProducer(primes);</span><br><span class="line">    producer.start();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(needMorePrimes())&#123;</span><br><span class="line">            consume(primes.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        producer.cancel(); <span class="comment">// 如果producer已经阻塞，将无法取消</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>每个线程中都有一个中断状态，当中断线程时，其状态将被置为ture，并且，<code>Thread</code>中提供了设置以及查询线程中断状态的方法：</p>
<figure class="highlight java"><figcaption><span class="caption">Thread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">// 中断目标线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">// 返回目标线程的中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 清除当前线程的中断状态(清除中断状态的唯一方法)，并返回之前的值</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>interrupted</code>时要注意，因为它会清除当前线程的中断状态。如果返回<code>true</code>，说明收到过中断请求，所以除非想屏蔽这个中断，否则应该对它进行处理：比如抛出<code>InterruptedException</code>，或者再次调用<code>interrupt</code>来恢复中断状态<font color="Gray">（这样还可以保留中断请求，并在之后的某个时候进行检查和处理）。</font></p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后由具体的线程任务来决定是否检查以及如何处理。也就是说，<font color="#E51508">中断并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时机做出中断响应。</font>如果任务不进行检查处理，那中断状态的设置也只是设置而已。</p>
<p>常见的阻塞方法有<code>Thread.sleep</code>和<code>Object.wait</code>等，它们会检查线程中断，并在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出<code>InterruptedException</code>，表示阻塞操作由于中断而提前结束。</p>
<h4 id="2-1-改进：中断素数生成器"><a href="#2-1-改进：中断素数生成器" class="headerlink" title="2.1. 改进：中断素数生成器"></a>2.1. 改进：中断素数生成器</h4><p>通常，中断是实现取消最合理的方式，如果任务能够响应中断，那么可以使用中断作为取消机制，并且可以利用类库提供的中断支持。上面的示例中说明了一些自定义的取消机制无法与可阻塞的库函数实现良好的交互，而使用终端则可以很容易地解决。</p>
<figure class="highlight java"><figcaption><span class="caption">PrimeProducer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    </span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">//直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PrimeProducer</code>中有两个位置可以检测中断：即阻塞的<code>put</code>方法，和循环开始处的判断。</p>
<p>由于调用了阻塞的<code>put</code>方法，因此可以不进行显示的检测，因为<code>put</code>会检测并响应中断，并抛出<code>InterruptedException</code>使任务退出。但在循环开始处执行检测会提高对中断的响应性，如果可阻塞的方法调用频率不高，则不足以获得足够的响应性。</p>
<h4 id="2-2-中断策略"><a href="#2-2-中断策略" class="headerlink" title="2.2. 中断策略"></a>2.2. 中断策略</h4><p>最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，并在必要时进行清理，通知某个所有者该线程已经退出。一个中断请求可能有一个或多个接收者，比如中断线程池中的某个工作线程，意味着取消当前任务，同时也意味着关闭工作线程。<font color="#E51508">区分任务和线程对中断的响应是很重要的，任务不会在其自己拥有的线程中执行，而是在某个服务拥有的线程中执行。</font>对于非线程所有者的代码来说（比如对于线程池而言，任何在线程池实现以外的代码），应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应。</p>
<p>.<font color="Gray">线程是系统提供的一个执行上下文，java中提供了一些对象帮我们管理线程并代理对进行的操作，比如Thread.start()就是开启一个执行上下文，这些对象就是线程的拥有者，即拥有线程的代码。如果我们要执行一段处理逻辑，就将这段逻辑封装成一个任务并委托给这些对象去挂到线程上执行，这段逻辑代码或者这个任务也就是非线程所有者的代码</font>。</p>
<p>.<font color="Gray">如果希望线程能够复用，那么线程拥有者代码可以在线程执行完一个任务后将线程挂起，然后等待下一个任务。那么问题来了：如果本来想结束服务，中断所有的工作线程，但是中断请求却被线程当前执行的任务代码吃掉了，并且未做任何处理，那么当任务结束后，线程拥有者将感知不到中断请求从而不能结束自己。因此，任务代码应该保留中断请求，这样当自己结束后可以交给线程拥有者处理</font>。</p>
<p>.<font color="Gray">线程池的设计中考虑到了这点，它定义和维护了一套自己的状态，并在很多节点进行检查，比如在新建和回收工作线程时，因此，即便任务中吃掉了中断请求，它也能根据自己的状态判定是否应该结束服务</font>。</p>
<p>这就是为什么大多数可阻塞的库函数只是抛出<code>InterruptedException</code>作为中断响应，因为它们永远不会在某个由自己拥有的线程中执行，因此它们为任务或者库代码采用了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，使调用栈上的上层代码可以采取进一步的操作。</p>
<h4 id="2-3-中断响应"><a href="#2-3-中断响应" class="headerlink" title="2.3. 中断响应"></a>2.3. 中断响应</h4><p>处理中断通常有两种策略：<font color="#E51508">传递异常</font>，使自己的方法也成为可中断的方法；或者<font color="#E51508">恢复中断状态</font>，交给调用栈上层的代码进行处理；</p>
<p>如果不想或无法传递异常（可能任务是通过<code>Runnable</code>来定义的），那么需要寻找另一种方式来保存中断请求。一种标准的方法就是通过再次调用<code>interrupt</code>来恢复中断状态。</p>
<p>不应该屏蔽<code>InterruptedException</code>，比如在<code>catch</code>中捕获异常却不做任何处理，除非代码中实现了线程的中断策略。虽然上面示例中<code>PrimeGenerator</code>屏蔽了中断，那是因为它已经知道线程将要结束，已经不需要上层代码进行处理。但大多数代码并不知道它们将在哪个线程中运行，因此应该保存中断状态。</p>
<p>对于一些不支持取消但可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。这种情况下，它们应该在本地保存中断状态，并在返回前恢复，而不是捕获<code>InterruptedException</code>时恢复。如果过早地设置中断状态，则可能引起无限循环，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现状态被设置时会立即抛出。</p>
<figure class="highlight java"><figcaption><span class="caption">getNextTask</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Taskgt&gt; queue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> queue.take();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(interrupted)&#123; <span class="comment">// 返回前恢复中断状态的设置</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时在取消过程中可能还涉及到其他状态，中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步的指示。例如，当一个由线程池拥有的工作线程检测到中断时，它会检查线程池是否正在关闭。如果是，它会在结束之前执行一些线程池清理工作，否则，它可能创建一个新线程将线程池恢复到合理的规模。</p>
<h3 id="3-示例：计时任务"><a href="#3-示例：计时任务" class="headerlink" title="3. 示例：计时任务"></a>3. 示例：计时任务</h3><p>需求：将给定的任务执行指定的时间，并保存异常信息</p>
<h4 id="3-1-通过外部线程中断"><a href="#3-1-通过外部线程中断" class="headerlink" title="3.1. 通过外部线程中断"></a>3.1. 通过外部线程中断</h4><figure class="highlight java"><figcaption><span class="caption">timedRun</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable currentTask,<span class="keyword">long</span> timeout,TimeUnit unit)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread currentThread = Thread.currentThread();</span><br><span class="line">	</span><br><span class="line">    cancelExec.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            currentThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeout, unit);</span><br><span class="line">    </span><br><span class="line">    currentTask.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timedRun</code>可以在任意线程中调用，它无法知道这个调用线程的中断策略。可能线程就不响应中断，那么<code>timedRun</code>只能在任务结束时才返回，此时可能已经超时。也可能任务在超时之前完成，那么中断<code>timedRun</code>所在线程的请求将在任务结束后到达，而那时可能已经在运行其它的代码了，因此，结果一定是不好的。</p>
<h4 id="3-2-改进：通过专门线程中断"><a href="#3-2-改进：通过专门线程中断" class="headerlink" title="3.2. 改进：通过专门线程中断"></a>3.2. 改进：通过专门线程中断</h4><figure class="highlight java"><figcaption><span class="caption">timedRun</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对任务进行包装</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RethrowableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable t;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">                <span class="keyword">this</span>.t = t;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rethrow</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> launderThrowable(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RethrowableTask task = <span class="keyword">new</span> RethrowableTask();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 新建一个专门的线程来执行任务</span></span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">    taskThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对执行线程进行限时</span></span><br><span class="line">    cancelExec.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            taskThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeout, unit);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使当前线程join等待执行任务的线程结束</span></span><br><span class="line">    taskThread.join(unit.toMillis(timeout)); </span><br><span class="line">    task.rethrow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timedRun</code>在启动任务线程后，执行一个限时的<code>join</code>方法，同步等待这个线程结束或者超时。在<code>join</code>返回后，再检查任务是否有异常抛出。</p>
<p>自定义执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍能返回到它的调用者。但这只是保证了方法能限时返回，并不代表任务能限时结束，如果任务本身不响应中断，那么它将继续运行下去，而且由于依赖限时<code>join</code>，将无法知道任务是正常结束了还是<code>join</code>超时返回。</p>
<h4 id="3-3-改进：通过Future中断"><a href="#3-3-改进：通过Future中断" class="headerlink" title="3.3. 改进：通过Future中断"></a>3.3. 改进：通过Future中断</h4><figure class="highlight java"><figcaption><span class="caption">timedRun</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        task.get();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(TimeoutException e)&#123;</span><br><span class="line">        <span class="comment">//取消任务</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause()); <span class="comment">// 如果任务中有异常，那么重新抛出</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        task.cancel(<span class="keyword">true</span>); <span class="comment">// 如果任务还在运行，那么将被中断，但对已经结束的任务没有影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>submit</code>会返回一个<code>Future</code>来描述任务的状态，另外，<code>Future</code>提供<code>cancel</code>方法，并带有一个<code>boolean</code>参数，判断是否对执行的任务进行中断，如果为false，就直接唤醒在get()上阻塞的任务，并返回一个取消异常，至于任务还是照样执行，只是结果不要了。而如果为true， 则是在唤醒等待结果的线程之前先对执行的任务发出一个中断请求，至于中断请求是否得到响应，则看具体任务的实现。</p>
<h3 id="4-不可中断的阻塞问题"><a href="#4-不可中断的阻塞问题" class="headerlink" title="4. 不可中断的阻塞问题"></a>4. 不可中断的阻塞问题</h3><p>并非所有的可阻塞方法或阻塞机制都能响应中断，<font color="#E51508">对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求必须指定线程阻塞的原因</font>。</p>
<ul>
<li><p><strong>Java.io中的同步Socket</strong>：在服务器应用程序中，最常见的阻塞I/O形式就是对套接字的读取和写入。虽然<code>InputStream</code>和<code>OutputStream</code>中的<code>read</code>和<code>write</code>等方法都不会响应中断，但通过关闭底层的套接字，可以使由于执行<code>read</code>或<code>write</code>等方法而被阻塞的线程抛出一个<code>SocketException</code>。</p>
</li>
<li><p><strong>Java.io中的同步I/O</strong>：当中断一个正在<code>InterruptibleChannel</code>上等待的线程时，将抛出<code>ClosedByInterruptException</code>，并关闭链路（这会使得其他在这条链路上阻塞的线程同样抛出<code>ClosedByInterruptException</code>）。当关闭一个<code>InterruptibleChannel</code>时，将导致所有在链路上阻塞的线程都抛出<code>AsynchronousCloseException</code>。</p>
</li>
<li><p><strong>selector的异步I/O</strong>：如果一个线程在调用<code>Selector.select</code>方法时阻塞了，那么调用<code>close</code>或<code>wakeup</code>方法会使线程抛出<code>ClosedSelectorException</code>并提前返回。</p>
</li>
<li><p><strong>获取某个锁</strong>：如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，它不会理会中断请求。但在<code>Lock</code>中提供了<code>lockInterruptibly</code>等方法，其允许在等待锁的同时仍能响应中断。</p>
</li>
</ul>
<h4 id="4-1-重写-Thread-interrupt"><a href="#4-1-重写-Thread-interrupt" class="headerlink" title="4.1. 重写 Thread.interrupt()"></a>4.1. 重写 Thread.interrupt()</h4><figure class="highlight java"><figcaption><span class="caption">ReaderThread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream in;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.in = socket.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = in.read(buf);</span><br><span class="line">                <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    processBuffer(buf,count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于非标准的取消操作，一种办法是重写<code>interrupt</code>方法，将取消动作封装在<code>Thread</code>中。</p>
<p>比如<code>ReaderThread</code>管理了一个套接字连接，采用同步方式从该套接字中读取数据，并将接收到的数据传递给<code>processBuffer</code>。为了结束某个用户的连接或者关闭服务器，<code>ReaderThread</code>改写了<code>interrupt</code>方法，使其既能响应中断，也能关闭<code>Socket</code>。</p>
<h4 id="4-2-定制-ThreadPoolExecutor-newTaskFor"><a href="#4-2-定制-ThreadPoolExecutor-newTaskFor" class="headerlink" title="4.2. 定制 ThreadPoolExecutor.newTaskFor"></a>4.2. 定制 ThreadPoolExecutor.newTaskFor</h4><p>1.定义<code>CancellableTask</code>扩展<code>Callable</code>接口，增加一个<code>cancel</code>方法和一个<code>newTask</code>工厂方法来构造<code>RunnableFuture</code></p>
<figure class="highlight java"><figcaption><span class="caption">CancellableTask</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTask</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.定义<code>CancellingExecutor</code>扩展<code>ThreadPoolExecutor</code>，改写<code>newTaskFor</code>返回自定义的<code>Future</code></p>
<figure class="highlight java"><figcaption><span class="caption">CancellingExecutor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CancellingExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(callable <span class="keyword">instanceof</span> CancellableTask)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((CancellableTask&lt;T&gt;)callable).newTask();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor(callable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.定义<code>SocketUsingTask</code>实现<code>CancellableTask</code>，在<code>cancel</code>中关闭套接字，并在<code>newTask</code>构造的<code>RunnableFuture</code>中重写<code>Future.cancel()</code>，即调用自己的<code>cancel</code>进行套接字关闭。</p>
<figure class="highlight java"><figcaption><span class="caption">SocketUsingTask</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span><span class="params">(Socket s)</span></span>&#123;</span><br><span class="line">        socket = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    SocketUsingTask.<span class="keyword">this</span>.cancel();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-停止基于线程的服务"><a href="#5-停止基于线程的服务" class="headerlink" title="5. 停止基于线程的服务"></a>5. 停止基于线程的服务</h3><p>应用程序通常会拥有多个线程服务，比如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也应该结束，以便使jvm正常退出。  </p>
<p>与其他封装对象一样，<font color="#E51508">线程的所有权是不可传递的</font>：应用程序可以拥有服务，服务可以拥有工作线程，但应用程序并不能拥有工作线程。因此，应用程序不能直接停止工作线程，相反，服务应该提供生命周期方法，来关闭它自己以及它所拥有的线程。这样，当应用程序关闭该服务时，再由服务关闭所拥有的线程。比如<code>ExecutorService</code>中提供的<code>shutdown</code>和<code>shutdownNow</code>方法。</p>
<h3 id="6-示例：日志服务"><a href="#6-示例：日志服务" class="headerlink" title="6. 示例：日志服务"></a>6. 示例：日志服务</h3><figure class="highlight java"><figcaption><span class="caption">LogWriter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    writer.println(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> </span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;    </span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LogWriter</code>给出了一个简单的日志服务，产生日志的线程由<code>LogWriter</code>通过<code>BlockingQueue</code>将日志交给打印线程，并由打印线程写出。</p>
<p>要停止打印线程很容易，因为它调用的<code>take</code>能响应中断，因此，只需中断打印线程就能停止服务。但是，这样直接关闭会丢失队列中正在等待写出的日志，而其他线程将在<code>log</code>上阻塞，因为日志队列很快会填满。因此，<font color="#E51508">当取消一个生产—消费操作时，应该同时取消生产者和消费者。</font>而示例中由于生产者并不是专门的线程，因此很难取消。</p>
<h4 id="6-1-改进：设置关闭标志"><a href="#6-1-改进：设置关闭标志" class="headerlink" title="6.1. 改进：设置关闭标志"></a>6.1. 改进：设置关闭标志</h4><p>可以设置一个关闭标志，以避免进一步提交日志，并在收到关闭请求后，消费者将队列中的所有消息写入日志，并解除所有在<code>log</code>上阻塞的线程</p>
<figure class="highlight java"><figcaption><span class="caption">LogWriter</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> reservations;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(PrintWriter writer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            logger.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// syn(检测是否已关闭，否则计数+1)，然后put日志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line marked">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line marked">            <span class="keyword">if</span>(isShutdown)&#123;</span><br><span class="line marked">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line marked">            &#125;</span><br><span class="line marked">            ++reservations;</span><br><span class="line marked">        &#125;</span><br><span class="line marked">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// syn(检测是否已关闭，并且日志消费完)，否则take日志，syn(计数-1)，最后print日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line marked">                        <span class="keyword">synchronized</span>(LogWriter.<span class="keyword">this</span>)&#123;</span><br><span class="line marked">                            <span class="keyword">if</span>(isShutdown &amp;&amp; reservations == <span class="number">0</span>)&#123;</span><br><span class="line marked">                                <span class="keyword">break</span>;</span><br><span class="line marked">                            &#125;</span><br><span class="line marked">                        &#125;</span><br><span class="line marked">                        String msg = queue.take();</span><br><span class="line marked">                        <span class="keyword">synchronized</span>(LogWriter.<span class="keyword">this</span>)&#123;</span><br><span class="line marked">                            --reservations;</span><br><span class="line marked">                        &#125;</span><br><span class="line marked">                        writer.println(msg);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为<code>LogWriter</code>提供可靠的关闭操作需要解决竞态条件问题，因此，要使日志消息的提交操作成为原子操作。但是，并不希望在消息加入队列时去持有一个锁，因为<code>put</code>方法本身就可以阻塞。</p>
<p>可以通过原子方式来检查关闭请求，并有条件地递增一个计数器。通过关闭标志和计数器，可以确保在关闭日志服务时，所有已经提交的日志都能被写出。</p>
<h4 id="6-2-改进：委托ExecutorService"><a href="#6-2-改进：委托ExecutorService" class="headerlink" title="6.2. 改进：委托ExecutorService"></a>6.2. 改进：委托ExecutorService</h4><p>简单的程序可以直接在<code>main</code>函数中启动和关闭全局的<code>ExecutorService</code>，但在复杂的程序中，通常会将<code>ExecutorService</code>封装在某个更高级别的服务中，并且该服务能提供自己的生命周期方法。</p>
<p>通过封装<code>ExecutorService</code>，可以将线程的所有权从<code>ExecutorService</code>扩展到服务以及应用程序，所有权链上的各个成员都将管理它所拥有的服务或线程的生命周期。</p>
<figure class="highlight java"><figcaption><span class="caption">LogService</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">            exec.awaitTermination(timeout, unit);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WriteTask(msg));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(RejectedExecutionException e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-单次任务服务"><a href="#7-单次任务服务" class="headerlink" title="7. 单次任务服务"></a>7. 单次任务服务</h3><p>如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一个私有的<code>Executor</code>来简化服务的生命周期管理，这个<code>Executor</code>的生命周期由这个方法来控制。</p>
<figure class="highlight java"><figcaption><span class="caption">checkMail</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkMail</span><span class="params">(Set&lt;String&gt; hosts,<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> AtomicBoolean hasNewMail = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> String host : hosts)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(checkMail(host))&#123;</span><br><span class="line">                        hasNewMail.set(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        exec.awaitTermination(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasNewMail.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkMail</code>能在多台主机上并行地检查新邮件，它创建一个私有的Executor，并向每台主机提交一个任务。当所有邮件检查任务都执行完成后，关闭Executor，等待结束。</p>
<h3 id="8-ExecutorService-shutdownNow的问题"><a href="#8-ExecutorService-shutdownNow的问题" class="headerlink" title="8. ExecutorService.shutdownNow的问题"></a>8. ExecutorService.shutdownNow的问题</h3><p>通过<code>shutdownNow</code>来强行关闭<code>ExecutorService</code>时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，但是无法知道哪些任务已经开始但尚未结束。</p>
<figure class="highlight java"><figcaption><span class="caption">TrackingExecutor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; taskCancellAtShutdown = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Runnable&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrackingExecutor</span><span class="params">(ExecutorService exec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exec = exec;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!exec.isTerminated())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt;(taskCancellAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span></span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isShutdown() &amp;&amp; Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                        taskCancellAtShutdown.add(runnable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将ExecutorService的其他方法委托给exec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TrackingExecutor</code>装饰了<code>ExecutorService</code>，在<code>execute</code>中记录哪些任务是在关闭后取消的。在Executor结束后，getCancelledTasks返回被取消的任务清单。由于在<code>finally</code>中检测中断状态，因此如果任务要被记录，在返回时必须维持线程的中断状态，设计良好的任务都应该这样实现。</p>
<p>但<code>TrackingExecutor</code>中存在一个竞态条件，在<font color="#E51508">任务执行完最后一条指令</font>以及<font color="#E51508">线程池将任务标记为结束</font>的两个时刻之间，线程池可能被关闭，这样一些被认为取消的任务可能实际上已经完成，就可能导致误报（任务实际已经结束，但线程池关闭了，不会再进行记录）。不过如果任务两次执行的结果相同，例如网络爬虫程序，则可以忽略，否则，需要考虑这个风险。</p>
<p>.<font color="Gray">对于这里TrackingExecutor存在的竞态问题，如果可以将中断时保存取消的任务这件事交给任务自己去做，即任务过程中如果检测到中断就将自己记录到取消任务中，并且任务自己清楚任务到底完成到什么进度。但这里对于TrackingExecutor，提交给它的并不是定制的任务，它只能通用的假设任务的中断处理方式是向上传递</font>。</p>
<ul>
<li>TrackingExecutor的使用示例：网页爬虫</li>
</ul>
<p>当爬虫程序必须关闭时，我们通常希望保存它的状态，以便稍后重新启动</p>
<figure class="highlight java"><figcaption><span class="caption">WebCrawler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebCrawler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> TrackingExecutor  exec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; urlsToCrawl = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        exec = <span class="keyword">new</span> TrackingExecutor(Executors.newCachedThreadPool());</span><br><span class="line">        <span class="keyword">for</span>(URL url : urlsToCrawl)&#123;</span><br><span class="line">            submitCrawlTask(url);</span><br><span class="line">        &#125;</span><br><span class="line">        urlsToCrawl.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            saveUncrawled(exec.shutdownNow()); <span class="comment">// 未开始的任务</span></span><br><span class="line">            <span class="keyword">if</span>(exec.awaitTermination(timeout, unit))&#123;</span><br><span class="line">                saveUncrawled(exec.getCancelledTasks()); <span class="comment">// 已开始但被中断的任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            exec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;URL&gt; <span class="title">processPage</span><span class="params">(URL url)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveUncrawled</span><span class="params">(List&lt;Runnable&gt; uncrawled)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Runnable task : uncrawled)&#123;</span><br><span class="line">            urlsToCrawl.add(((CrawlTask)task).getPage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitCrawlTask</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> CrawlTask(url));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CrawlTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(URL link : processPage(url))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                submitCrawlTask(link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-线程的异常终止"><a href="#9-线程的异常终止" class="headerlink" title="9. 线程的异常终止"></a>9. 线程的异常终止</h3><p>导致线程提前死亡的常见原因就是<code>RuntimeException</code>，由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们不会被捕获，也不会在调用栈中逐层传递，而是默认在控制台中输出栈追踪信息，并终止线程，从而造成<font color="#E51508">线程泄露</font></p>
<p>如果任务抛出了一个未检查异常，那么它将使线程终结，但会首先通知服务该线程已经终结。然后，服务可能会用新的线程来代替，也可能不会，因为可能线程池正在关闭，或者当前已有足够多的线程满足需要。<code>ThreadPoolExecutor</code>和<code>Swing</code>都是通过这项技巧来确保行为糟糕的任务不会影响到后续任务的执行。</p>
<p>标准线程池允许当发生未捕获异常时结束线程，由于使用<code>try-finally</code>来接收通知，因此当线程结束时，将有新的线程来代替它。但如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致混乱。  </p>
<p>如下为典型的线程池工作者线程结构：</p>
<figure class="highlight java"><figcaption><span class="caption">run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            runTask(getTaskFromWorkQueue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        thrown = e;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        threadExited(<span class="keyword">this</span>,thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>UncaughtExceptionHandler</strong></li>
</ul>
<p><code>Thread</code>提供了<code>UncaughtExceptionHandler</code>，它能检测出某个线程由于异常而终结的情况。当一个线程由于异常而退出时，JVM会把这个事件报告给应用程序提供的<code>UncaughtExceptionHandler</code>异常处理器。如果没有任何异常处理器，那么默认的行为是将栈追踪信息输出到<code>System.err</code>，而通常的响应方式是将一个错误信息以及相应的栈追踪信息写入到日志中。</p>
<figure class="highlight java"><figcaption><span class="caption">UncaughtExceptionHandler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UncaughtExcept</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>，可以为池中的所有线程设置一个<code>UncaughtExceptionHandler</code>，但是，只有通过<code>execute</code>提交的任务，才能将抛出的异常交给异常处理器，而通过<code>submit</code>提交的任务，无论抛出的是未检查异常还是已检查异常，都将被任务视为返回状态的一部分。如果一个由<code>submit</code>提交的任务由于抛出了异常而结束，那么这个异常将在<code>Future.get</code>封装的<code>ExecutionException</code>中重新抛出。</p>
<h3 id="10-守护线程"><a href="#10-守护线程" class="headerlink" title="10. 守护线程"></a>10. 守护线程</h3><p>线程可以分为<font color="#E51508">普通线程</font>和<font color="#E51508">守护线程</font>，在JVM启动时创建的所有线程中，除主线程外，其他的都是守护线程，例如垃圾回收器以及其他执行辅助工作的线程。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>普通与守护的差异仅在当线程退出时发生的操作，当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃，即不会执行<code>finally</code>代码块，也不会执行回卷栈，而JVM只是直接退出。</p>
<p>应该<font color="#E51508">尽可能少地使用守护线程</font>，很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。</p>
<h3 id="11-关闭钩子"><a href="#11-关闭钩子" class="headerlink" title="11. 关闭钩子"></a>11. 关闭钩子</h3><p>jvm既可以正常地关闭，也可以强行关闭。正常关闭的方式有多种，包括当最后一个非守护线程结束时，或者当调用<code>System.exit</code>时。也可以通过<code>Runtime.halt</code>，或者在操作系统中杀死进程来强行关闭。</p>
<p>关闭钩子就是通过<code>Runtime.addShutdownHook</code>注册的但尚未开始的线程，可以注册多个关闭钩子，但jvm并不保证它们的调用顺序，且jvm不会停止或中断任何在关闭时仍然运行的应用线程，它们将一起并发执行。<font color="#E51508">当正常关闭时，jvm首先调用所有已注册的关闭钩子，</font>当jvm最终结束时，这些应用线程将被强行结束，因此关闭钩子应该要保证是线程安全，且在访问共享数据时要小心的避免死锁。<font color="#E51508">当强行关闭时，并不会运行关闭钩子，而只是关闭了jvm。</font></p>
<p>所以为了避免关闭钩子出现问题，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。一种可靠的建议是使用同一个关闭钩子，在钩子中执行一些列串行地操作。</p>
<h3 id="12-终结器"><a href="#12-终结器" class="headerlink" title="12. 终结器"></a>12. 终结器</h3><p>当不再需要内存资源时，可以通过垃圾回收器回收它们，但对于一些资源，例如文件句柄或套接字，当不再需要时，必须显示地交还给操作系统。因此，为了实现这个功能，java给对象定义了一个终结器<code>finalize()</code>，并且垃圾回收器在释放对象时也会检查并执行对象的<code>finalize()</code>，从而释放一些系统资源。</p>
<p>但<font color="#E51508">垃圾回收器的行为是不可控的，它的运行策略由jvm决定</font>，因此建议是避免使用，绝大多情况下，都可以使用<code>try-finally</code>来代替，而且工作的更好。</p>
<p>.<font color="Gray">这个在《深入理解Java虚拟机》中有更详细的介绍，另外在线程池的实现中可以见到这个方法的使用，因为如果服务关闭时忘了通知它，那么它确实没有其它办法，只能在被GC回收时由垃圾回收器帮忙检查释放资源</font>。</p>
<p><br><strong>参考：</strong> </p>
<ol>
<li>Copyright&nbsp;&copy;《java并发编程实战》</li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2019/01/08/20190108/">
		    《Java并发编程实战》 同步的性能问题
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2019/01/05/20190105/">
		    《Java并发编程实战》 任务的执行
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/Java并发编程实战/">Java并发编程实战</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/Future/">Future</a>   <a href="/tags/ThreadPool/">ThreadPool</a>
  </div>


         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-自定义取消"><span class="toc-text">1. 自定义取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-示例：取消素数生成器"><span class="toc-text">1.1. 示例：取消素数生成器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-中断"><span class="toc-text">2. 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-改进：中断素数生成器"><span class="toc-text">2.1. 改进：中断素数生成器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-中断策略"><span class="toc-text">2.2. 中断策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-中断响应"><span class="toc-text">2.3. 中断响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-示例：计时任务"><span class="toc-text">3. 示例：计时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-通过外部线程中断"><span class="toc-text">3.1. 通过外部线程中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-改进：通过专门线程中断"><span class="toc-text">3.2. 改进：通过专门线程中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-改进：通过Future中断"><span class="toc-text">3.3. 改进：通过Future中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-不可中断的阻塞问题"><span class="toc-text">4. 不可中断的阻塞问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-重写-Thread-interrupt"><span class="toc-text">4.1. 重写 Thread.interrupt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-定制-ThreadPoolExecutor-newTaskFor"><span class="toc-text">4.2. 定制 ThreadPoolExecutor.newTaskFor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-停止基于线程的服务"><span class="toc-text">5. 停止基于线程的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-示例：日志服务"><span class="toc-text">6. 示例：日志服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-改进：设置关闭标志"><span class="toc-text">6.1. 改进：设置关闭标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-改进：委托ExecutorService"><span class="toc-text">6.2. 改进：委托ExecutorService</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-单次任务服务"><span class="toc-text">7. 单次任务服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ExecutorService-shutdownNow的问题"><span class="toc-text">8. ExecutorService.shutdownNow的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-线程的异常终止"><span class="toc-text">9. 线程的异常终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-守护线程"><span class="toc-text">10. 守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-关闭钩子"><span class="toc-text">11. 关闭钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-终结器"><span class="toc-text">12. 终结器</span></a></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2023 &nbsp;&nbsp; version@1.0.0 &nbsp;&nbsp; shanhm1991
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
