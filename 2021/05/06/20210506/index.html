<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>算法 关于排序 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="排序即将一组对象按照某种逻辑顺序重新排列的过程，通常，整理数据的第一步就是进行排序，因此它是后面很多其它算法和数据结构的基础。在计算机早期年代，据说大约有30%的计算周期都花在了排序操作上，如今这个比例有所降低，并非排序的重要性降低了，而是前辈们不懈的研究，使得如今的排序算法更加高效。
在不同的场景下选择合适的排序算法其实是很重要的，比如下面是使用文中的几种排序策略对同样的1000个随机数进行排序的结果，可以看出来差距还是比较大的
1234567SELECT         comp=511566  swap=251579  cost=16355msINSERT         comp=252594  wap=251584   cost=16449msINSERT_BINARY  comp=14294   move=1011    cost=111msINSERT_XIER    comp=13576   swap=8453    cost=578msMERGE          comp=9413    swap=0       cost=68msQUICK          comp=15391   swap=2225    cost=191msQUICK2         comp=13857   swap=13853   cost=905ms">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="算法 关于排序"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#ADA5A0; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #999;">articles:  108 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20210506" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-05-05T16:00:00.000Z"><a href="/2021/05/06/20210506/">2021-05-06</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        算法 关于排序
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 5.7k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 23min</font>
   
   
  
  <div class="categories">
    <a href="/categories/算法设计/">算法设计</a>
  </div>


   
   

   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>排序即将一组对象按照某种逻辑顺序重新排列的过程，通常，整理数据的第一步就是进行排序，因此它是后面很多其它算法和数据结构的基础。在计算机早期年代，据说大约有30%的计算周期都花在了排序操作上，如今这个比例有所降低，并非排序的重要性降低了，而是前辈们不懈的研究，使得如今的排序算法更加高效。</p>
<p>在不同的场景下选择合适的排序算法其实是很重要的，比如下面是使用文中的几种排序策略对同样的1000个随机数进行排序的结果，可以看出来差距还是比较大的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT         comp=<span class="number">511566</span>  swap=<span class="number">251579</span>  cost=<span class="number">16355</span>ms</span><br><span class="line">INSERT         comp=<span class="number">252594</span>  wap=<span class="number">251584</span>   cost=<span class="number">16449</span>ms</span><br><span class="line">INSERT_BINARY  comp=<span class="number">14294</span>   move=<span class="number">1011</span>    cost=<span class="number">111</span>ms</span><br><span class="line">INSERT_XIER    comp=<span class="number">13576</span>   swap=<span class="number">8453</span>    cost=<span class="number">578</span>ms</span><br><span class="line">MERGE          comp=<span class="number">9413</span>    swap=<span class="number">0</span>       cost=<span class="number">68</span>ms</span><br><span class="line">QUICK          comp=<span class="number">15391</span>   swap=<span class="number">2225</span>    cost=<span class="number">191</span>ms</span><br><span class="line">QUICK2         comp=<span class="number">13857</span>   swap=<span class="number">13853</span>   cost=<span class="number">905</span>ms</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>为了方便说明和比较各种排序算法，这里先设计一个排序工具类<code>Sorts</code>，其提供对<code>List</code>进行排序的接口，同时支持对排序策略的选择，还可以通过给定比较器<code>Comparator</code>来设置排序的顺序</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, String algorithm, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span> </span>&#123;</span><br><span class="line">    doSort(list, algorithm, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSort</span><span class="params">(List&lt;E&gt; list, String algorithm, Comparator&lt;? <span class="keyword">super</span> E&gt; comp)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"before sort: &#123;&#125;"</span>, list); </span><br><span class="line"></span><br><span class="line">    Object[] array = list.toArray();</span><br><span class="line">    <span class="keyword">switch</span>(algorithm)&#123;</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_SELECT: sort_select(array, comp); <span class="keyword">break</span>;               <span class="comment">// 选择排序（冒泡）</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT: sort_insert_swap(array, comp); <span class="keyword">break</span>;          <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT_BINARY: sort_insert_binary(array, comp); <span class="keyword">break</span>; <span class="comment">// 插入排序（二分法改进）</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_INSERT_XIER: sort_xier(array, comp); <span class="keyword">break</span>;            <span class="comment">// 希尔排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_MERGE: sort_merge(array, comp); <span class="keyword">break</span>;                 <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_QUICK: sort_quick(array, comp); <span class="keyword">break</span>;                 <span class="comment">// 快速排序</span></span><br><span class="line">    <span class="keyword">case</span> ALGORITHM_QUICK2: sort_quick2(array, comp); <span class="keyword">break</span>;               <span class="comment">// 快速排序（重复场景改进）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; i = list.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : array) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在内部定义两个统一的操作，即比较<code>comp</code>和交换<code>swap</code>，这样方便查看排序的过程，以及比较各个排序算法的复杂度</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comp</span><span class="params">(Object[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b, Comparator comp)</span> </span>&#123;</span><br><span class="line">    times_compare++;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">"%60s %2s comp：%2s&lt;&gt;%2s ([%2s]&lt;&gt;[%2s])"</span>, <span class="string">" "</span>, times_compare, array[a], array[b], a, b)); </span><br><span class="line">    <span class="keyword">if</span>(comp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> comp.compare(array[a], array[b]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Comparable)array[a]).compareTo(array[b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] array, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Object t = array[a];</span><br><span class="line">    array[a] = array[b];</span><br><span class="line">    array[b] = t;</span><br><span class="line">    times_swap++;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">"%2s swap： %2s&lt;&gt;%2s ([%2s]&lt;&gt;[%2s]) = %s"</span>, times_swap, array[b], array[a], a, b, Arrays.toString(array))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面构造一个<code>List[5, 2, 10, 7, 6, 3, 8, 4]</code>，然后分别使用不同的排序算法来对其进行排序和复杂度分析比较 </p>
<h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h4><p>选择排序是很容易理解和简单的一种排序：即每次从剩下的元素中找出最小的元素进行排定</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_select</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(comp(array, i, j, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(array, i ,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.<font color="gray">这里写的冒泡实现，思路是一样的，只是没有用一个临时变量来记录最小值，区别就是交换次数偏多，但比较次数一样</font></p>
<p><img src="/img/20210506/20210506.1.jpg" alt=""></p>
<p>选择排序的<font color="#E51508">时间复杂度与输入的初始顺序无关</font>，也就是无论输入时是怎样的顺序，其比较和交换次数都是固定的。</p>
<p>由于每次交换都能排定一个元素，所以最多只需要寻找并交换 $N-1$ 次，但<font color="#E51508">每次遍历寻找最小元素的操作，并不能为下一次遍历提供有用信息</font>，因此即便对于一个已经排序的数组，同样需要比较次数：$(N-1) + (N-2) + … + 1 = N(N-1)/2 \in N^2$ </p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h4><p>选择排是每次<font color="#E51508">将待排元素与剩下的无序数组进行排序</font>，所以它每次都要与剩下的所有元素进行比较，这样前面的排序操作无法为后续的工作提供提供条件。</p>
<p>相反的，插入排序每次<font color="#E51508">将待排元素与已排定的元素进行排序</font>，这样就不一定每次都要与所有已排定的元素进行比较了，只要找到正确的位置就可以停止比较了，可以想象一下抓牌的过程，每次抓到一张新牌都是将其插入到前面已经有序的牌中。</p>
<p>与选择排序一样，当前位置左边的所有元素都是有序的，但是它们的最终位置还不确定，为了给更小的元素腾出位置，它们可能还会被移动，当索引到达数组最右端时，数组排序也就完成了。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_insert_swap</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; comp(array, j, j - <span class="number">1</span>, comp) &lt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            swap(array, j-<span class="number">1</span> ,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.2.jpg" alt=""></p>
<p>插入排序的<font color="#E51508">时间复杂度与输入的初始顺序相关</font>，最好的情况是数组已经排序，那么只需要 $N-1$ 次比较和 $0$ 次交换，相反，最差情况则是逆序数组，那么就需要 $N(N-1)/2$ 次比较，以及 $N(N-1)/2$ 次交换，如果取平均复杂度，那就是好坏参半，可以约为 $\in N^2/4$</p>
<ul>
<li><strong>改进</strong></li>
</ul>
<p>对于插入操作，还可以通过二分法改进一下，即每次从已排定数组的中间位置开始进行比较，这样便可以将每次插入时的比较次数稳定在 $\log_{2} {k}$，其中 $k$ 是每次插入时已排定的元素个数，当然具体实现时还可以找到一些优化点，比如当遇到大小相等的元素时便可以原地插入，并不一定要二分法进行到最后。</p>
<p>这样在大部分情况下应该都能提高插入排序的效率，但如果原数组已经高度有序，那么效率反而不如标准版的插入排序，另外由于二分法插入是跳着进行比较的，所以这里用移动操作<code>move</code>代替了交换操作<code>swap</code>。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_insert_binary</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(comp(array, <span class="number">0</span>, <span class="number">1</span>, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        swap(array, <span class="number">0</span> ,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(array.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = mid(array, i, comp);</span><br><span class="line">            <span class="keyword">if</span>(comp(array, i, mid, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                move(array, mid + <span class="number">1</span>, i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                move(array, mid, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(Object[] array, <span class="keyword">int</span> target, Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = target;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(mid &gt; left &amp;&amp; mid &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(comp(array, target, mid, comp) &lt; <span class="number">0</span>)&#123; </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(comp(array, target, mid, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 等于位置直接可以原地插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(Object[] array, <span class="keyword">int</span> mid, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Object t = array[target];</span><br><span class="line">    System.arraycopy(array, mid, array, mid + <span class="number">1</span>, target - mid);</span><br><span class="line">    array[mid] = t;</span><br><span class="line">        </span><br><span class="line">    times_swap++;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">"%2s move： %s([%s]-&gt;[%s]) = %s"</span>, times_swap, t, target, mid, Arrays.toString(array)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h4><p>由于插入排序对初始顺序的敏感性，那么<font color="#E51508">对于一个数组，如果能提高其局部有序性，就可以降低在插入排序时的比较次数</font>，而希尔排序应该就是基于这个想法对插入排序进行的改进。</p>
<p>具体做法是将原数组按照固定间隔 h 拆分成若干个独立的子数组，然后分别对这些子数组进行排序，那么对这些子数组的排序即提高了原数组的局部有序性，而由这些有序子数组构成的数组，我们称其为 h 有序。</p>
<p>考虑大规模的数组，如果最小元素在数组尽头，那么通过插入排序要将它移到正确的位置就需要 N-1 次比较和移动。而通过对数组进行 h 间隔拆分，如果 h 很大，那么就能一次将元素移动到很远的地方，然后再逐步减小 h 进行拆分，这样前面大 h 的排序结果就能为后面更小 h 的排序创造方便，并从整体上降低比较和交换次数，如果最终 h 为 1，那么就能将数组完成排序。</p>
<p>于是，希尔排序的性能就取决于 h 序列的选择，不仅取决于 h 的大小，还取决于 h 之间的公因子等数学性质，下面令 $h = h * 3 + 1$</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_xier</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; array.length / <span class="number">3</span>)&#123; </span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121,364, 1093 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"compare interval: &#123;&#125;"</span>, h); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; comp(array, j, j - h, comp) &lt; <span class="number">0</span>; j -= h)&#123;</span><br><span class="line">                swap(array, j-h ,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.5.jpg" alt=""></p>
<p>上面示例中的算法，在已知最坏情况下所需的比较次数大约为 $N^{3/2}$，这样希尔排序通过一个小小的改变就提高了插入排序的效率，并打破了平方级别的复杂度屏障，而且数组越大，优势越明显。</p>
<p>至于希尔排序复杂度的数学证明问题，已经超出了这里的讨论范围，不过可以尝试证明：<strong>当一个 h 有序的数组按照增幅 k 排序之后，其仍然是 h 有序的</strong></p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h4><p>归并排序是分治思想的一种体现，要将一个数组排序，可以先递归地将它分为两半分别排序，然后再逐步将结果归并起来。</p>
<p>然后<font color="#E51508">在每次合并操作时，都有一个前提，即左右两边数组都分别是有序的</font>，这样在合并的具体实现中，可以通过判断来省略一些步骤，比如当左子数组的最右元素，大于右子数组的最左元素时，就可以直接判定原数组已经有序，从而省略 merge 操作，另外，如果在 merge 的过程中，发现一边数组的元素已经全部用完，则可以直接将另一边数组剩余的元素进行整体拷贝，无需再逐个比较。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_merge</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    Object[] temp = array.clone();</span><br><span class="line">    recursion_mid(array, temp, <span class="number">0</span>, array.length - <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion_mid</span><span class="params">(Object[] array, Object[] temp, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    LOGGER.debug(<span class="string">"mid=&#123;&#125;"</span>, mid); </span><br><span class="line"></span><br><span class="line">    recursion_mid(array, temp, low, mid, comp);</span><br><span class="line">    recursion_mid(array, temp, mid + <span class="number">1</span>, high, comp);</span><br><span class="line">    merge(array, temp, low, mid, high, comp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Object[] array, Object[] temp, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(comp(array, mid + <span class="number">1</span>, mid, comp) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"mid=&#123;&#125; merge skipped..."</span>, mid); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.arraycopy(array, low, temp, low, high - low + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(comp(temp, i, j, comp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            array[k] = temp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            array[k] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)&#123; </span><br><span class="line">            System.arraycopy(temp, j, array, k + <span class="number">1</span>, high - j + <span class="number">1</span>); <span class="comment">// skip left copy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; high)&#123;</span><br><span class="line">            System.arraycopy(temp, i, array, k + <span class="number">1</span>, mid - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.debug(<span class="string">"mid=&#123;&#125; merge &#123;&#125;"</span>, mid, Arrays.toString(array)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.3.jpg" alt=""></p>
<p>归并排序的缺点是在合并结果时，需要借助临时数组来整理顺序，然后再将临时数组中已排序的元素按照对应位置拷贝回原数组，这就增加了空间复杂度，并且所需的额外内存空间与 N 成正比，但是它对于时间复杂度可以保证：对于长度为 N 的任意数组进行排序，所需的比较次数最多为 $O(N\log_{2} {N}) $</p>
<ul>
<li><strong>证明：</strong> </li>
</ul>
<p>首先，对于任意长度为 $n$ 的数组，将其所需的比较次数（时间复杂度）记为：$T(n)$， 那么有：$T(n) = 0$， $n \leq 1$ </p>
<p>如果将长度 $n$ 的数组一分为二，则可以将其所需的比较次数表示为：$T(n) = 2 \times T(\frac{n}{2}) + C(n)$</p>
<p>$C(n)$ 表示两边子数组合并所需的比较次数，最差情况是两个数组中的元素交叉排列，比如 [2,4,6,8] 与 [1,3,5,7] 那么 $C(n) = n - 1$</p>
<p>下面将拆分次数记为：$k$</p>
<p>于是：$k = 1$，有：$T(n) = 2 \times T(\frac{n}{2}) + n - 1 $</p>
<p>对$\frac{n}{2}$继续拆分，即$k = 2$，则有：$T(n) = 2 \times (2 \times T(\frac{n}{4}) + \frac{n}{2} -1) + n - 1 = 4 \times T(\frac{n}{4}) + 2n - 1 - 2$</p>
<p>对$\frac{n}{4}$继续拆分，即$k = 3$，则有：$T(n) = 2 \times (2 \times (2 \times T(\frac{n}{8}) + n/4 - 1) + n/2 -1) + n - 1 = 8 \times T(\frac{n}{8}) + 3n - 1 - 2 - 4$</p>
<p><strong>…</strong>   </p>
<p>那么，在进行 $k$ 次拆分之后，则有：$T(n) = 2^k \times T(\frac{n}{2^k}) + kn - 1 - 2 - 4 -  … - 2^{k-1} = 2^k \times T(\frac{n}{2^k}) + kn + 1 - 2^k$</p>
<p>并且，如果最终在 $k$ 次拆分之后，子数组的元素个数都为 $1$，那么就有：$2^k = n$</p>
<p>故：$T(n) = n \times T(1) + n\log_{2} {n} + 1 - n = n\log_{2} {n} + 1 - n \in O(n\log_{2} {n})$ </p>
<p>类似的，在最好的情况下，每次合并操作只需要进行 $1$ 次比较，那么就有：$T(n) = 2^k \times T(\frac{n}{2^k}) + k = \log_{2} {n}$ </p>
<h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h4><p>快速排序也是分治思想的一种体现，它选取一个切分元素 K，然后将数组分成左右两个子数组，并保证左边子数组的所有元素都不大于 K，而右边子数组的所有元素都不小于 K，这样如果左右子数组都分别有序，那么整个数组就是有序的，然后，再对左右子数组以同样的方式进行递归操作，最终便完成了数组的排序。</p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_quick</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    recursion_partition(array, <span class="number">0</span>, array.length - <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion_partition</span><span class="params">(Object[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> partition = partition(array, low, high, comp);</span><br><span class="line">    LOGGER.debug(<span class="string">" partition=&#123;&#125;"</span>, partition);</span><br><span class="line">    </span><br><span class="line">    recursion_partition(array, low, partition - <span class="number">1</span>, comp);</span><br><span class="line">    recursion_partition(array, partition + <span class="number">1</span>, high, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>; <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </span><br><span class="line">        <span class="keyword">while</span>(++i &lt; high &amp;&amp; comp(array, low, i, comp) &gt; <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(--j &gt; low &amp;&amp; comp(array, low, j, comp) &lt; <span class="number">0</span>)&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(array, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low != j)&#123;</span><br><span class="line">        swap(array, low, j); <span class="comment">// 将切分元素交换到正确的位置 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20210506/20210506.4.jpg" alt=""></p>
<p>快速排序与归并排序是互补的，它可以直接在原地排序，而不需要借助临时数组来进行整理和拷贝。但是<font color="#E51508">在归并排序中，每次都能将数组等分为两半，而在快速排序中，切分的位置则取决于数组的内容</font>。比如示例中的最后几趟，每次只能将子数组长度减1，因此如果数组原本就是有序的状态，那么快速排序的复杂度反而会降为 $N^2$ 级别。</p>
<p>但是快速排序相对更加简洁，其在切分方法的内循环中只需用一个递增的索引将数组元素与一个定值进行比较，而在希尔排序和归并排序的内循环中，一般还要移动数据，所以它们一般都会比快速排序慢。</p>
<p>快速排序的最好情况是每次都能刚好将数组等分，这时它的复杂度分析可以类似于归并排序，有：$T(n) = 2T(\frac{n}{2}) + n \in O(N\log_{2} {N})$，但最差情况为 $N^2$，这显然难以令人接受，不过人们对于快速排序的信心来自于其平均复杂度的证明，约为 $1.39N\log_{2} {N}$。</p>
<p>但是，对平均复杂度的证明需要每个切分位置的概率问题，这显然很复杂，书中通过一种通用的方式将问题转化为对曲线的积分计算问题，如果对数学有兴趣的话，可以研究一下。 </p>
<ul>
<li><strong>改进</strong></li>
</ul>
<p>基于快速排序的特点，可以尝试做一些改进优化：</p>
<p>首先可以提高数组的顺序随机性，另外可以将小数组改为插入排序，比如在<code>java.util.Arrays</code>中启用插入排序的阈值就为7。</p>
<p>另外，可以每次从子数组中的小部分元素中计算一个中位数来进行切分，这样可以提高切分效果，但代价是需要计算中位数。</p>
<p>而在一些实际应用场景中，可能会存在大量重复的元素，这时如果使用标准快速排序，那么每次还是只选定一个切分元素将数组切分为两部分，但是如果能<font color="#E51508">以切分元素为界，将数组分为小于、等于、大于三部分，那么就可以降低下一次递归子数组的长度，也就降低了后续切分和比较的次数</font>，称为三向切分的快速排序。</p>
<p>其思路是从两侧将元素向中间靠，通过巧妙的设计三个索引<code>lt</code>,<code>i</code>,<code>gt</code>，其中<code>lt</code>是切分元素，<code>i</code>则是下一个要比较的元素<br>对于左端元素，如果小于切分元素就进行位置对调，<br>对于右端元素，每次比较前先与<code>i</code>交换位置，然后与<code>i</code>位置比较，如果等于直接将<code>i</code>右移一位，接着再对新的右端元素进行同样的操作 </p>
<p>这样就保证<code>i</code>位置就是切分元素，而且与其重复的元素都在左侧附近，并以<code>lt</code>和<code>gt</code>为左右边界</p>
<p>.<font color="gray">《算法》一书中的这个示例应该是有些问题，并不能正确排序，不过如果能看明白作者的意图，可以修正一下。另外，需要知道三向切分能提升性能的前提是数组中存在大量重复元素，因为其降低切分和比较次的背后，是以提高交换次数为代价的。</font></p>
<figure class="highlight java"><figcaption><span class="fileDir">https://github.com/shanhm1991/Echo/blob/master/src/main/java/io/github/echo/algorithms/</span><span class="caption">Sorts.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort_quick2</span><span class="params">(Object[] array, Comparator comp)</span> </span>&#123;</span><br><span class="line">    recursion_partition2(array, <span class="number">0</span>, array.length - <span class="number">1</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion_partition2</span><span class="params">(Object[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, Comparator comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high &lt;= low)&#123; <span class="comment">// high - low &lt;= 8 改为插入排序</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = low, i = low + <span class="number">1</span>, gt = high;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = comp(array, i, lt, comp);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(array, lt++, i++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(array, i, gt--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recursion_partition2(array, low, lt - <span class="number">1</span>, comp);</span><br><span class="line">    recursion_partition2(array, gt + <span class="number">1</span>, high, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均运行时间，大幅偏离的情况非常罕见，因此可以肯定三向切分快速排序的运行时间与输入信息量 N 是成正比的。在实际应用中这个性质很重要，因为对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。</p>
<h3 id="关于空间复杂度"><a href="#关于空间复杂度" class="headerlink" title="关于空间复杂度"></a>关于空间复杂度</h3><p>上面的讨论都是站在时间复杂度的问题上对各种排序算法进行的分析，但在实际应用中还有一个需要考虑的问题就是空间复杂度，即内存使用</p>
<p>下面主要从java实现的角度来分析一下其内存使用情况，因为对于一个使用java作为第一开发语言的程序员来讲，实现各种算法或数据结构时，一般都是先将数据封装成对象，比如链表中的节点Node，如果要考虑内存消耗，那么首先就是计算其中有多少属性数据以及哪些引用。</p>
<p>java最重要的特性之一就是其内存分配系统，它的目标是希望将开发者从对内存的操作之中解脱出来。作为一个面向对象的语言，它可以在对象头中记录一些额外信息，比如类引用、锁信息以及垃圾收集信息，然后配合引用计数统计信息，便能实现对垃圾对象占用内存的自动回收（当然具体实现肯定还需要考虑很多问题），然后以对象为单位统一对内存进行申请和释放操作。</p>
<p>对应的java中定义了8种基本数据类型，以及一个引用类型 reference（指向一个地址）</p>
<table width=100%>
        <tr style="border-bottom:0.01rem solid grey;">
            <th width=15%>类型</th>
            <th>字节</th>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>boolean</td>
            <td>1</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>byte</td>
            <td>1</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>short</td>
            <td>2</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>int</td>
            <td>4</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>float</td>
            <td>4</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>long</td>
            <td>8</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>double</td>
            <td>8</td>
        </tr>
        <tr style="border-bottom:0.01rem solid #ededed;">
            <td>reference</td>
            <td>8</td>
        </tr>
    </table>

<p>对于一个java对象，其内存消耗等于它所有实例变量使用的内存加上对象本身（对象头，一般是16字节）开销，以及对其填充（64位机器上，一般会将对象的内存使用填充为8的倍数）。</p>
<p>比如一个<code>int</code>所需的内存为4字节，而对应的一个<code>Integer</code>则需要24字节，数据4字节，对象头16字节，对其填充4字节；<br>对于一个长度为 N 的<code>int</code>数组，其所需内存为 24 + 4N，数组对象头24字节，因为需要额外4字节来存储数组长度，然后有4字节作为填充；<br>而对于一个长度为 N 的<code>Integer</code>数组，则需要 24 + 32N 字节，数组对象头24字节，每个<code>Integer</code>对象24字节，以及每个引用占用8字节</p>
<p>一般在设计一个通用的容器或者排序工具时，都会考虑使用泛型，而java中的泛型是通过在编译器中进行简单的类型擦除和强制转换来实现的，这就导致了其无法支持基本数据类型（因为基本类型与<code>Object</code>之间无法强制转换），然后java通过提供基本类型的自动装箱/拆箱操作来弥补了这个问题，但是这样是以降低性能以及更多的内存消耗作为代价的。所以java需要在JVM通过各种办法来对执行过程进行优化确实是一种刚需，它不像C++一样将优化手段直接放在编译器中进行，当然，作为具体语言的使用者只能聊聊一些使用体会，很难站到语言设计者的高度去考虑和权衡他们遇到的问题。</p>
<p><br><strong>参考：</strong></p>
<ol>
<li>《算法》</li>
<li><a href="https://zhuanlan.zhihu.com/p/341225128" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341225128</a></li>
<li><a href="https://www.cnblogs.com/zhyantao/p/10424874.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhyantao/p/10424874.html</a></li>
<li><a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">https://www.jianshu.com/p/e74eb43960a1</a></li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2021/05/15/20210515/">
		    算法 堆排序 &amp; PriorityQueue
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2020/06/01/20200601/">
		    《UNIX环境高级编程》 文件
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/算法设计/">算法设计</a>
  </div>


        

         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){

$("#java_ul").click(function(){ $("#java_li").toggle(); });
$("#frame_ul").click(function(){ $("#frame_li").toggle(); });
$("#os_ul").click(function(){ $("#os_li").toggle(); });
$("#db_ul").click(function(){ $("#db_li").toggle(); });
		
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-选择排序"><span class="toc-text">1. 选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-插入排序"><span class="toc-text">2. 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-希尔排序"><span class="toc-text">3. 希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-归并排序"><span class="toc-text">4. 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-快速排序"><span class="toc-text">5. 快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于空间复杂度"><span class="toc-text">关于空间复杂度</span></a></li></ol>
</div>




</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2022 shanhm1991 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
