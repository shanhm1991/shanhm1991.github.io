<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>JUC AbstractQueuedSynchronizer | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="队列同步器 AbstractQueuedSynchronizer（AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个int变量来表示同步状态，通过CAS操作对同步状态进行修改，确保状态的改变是安全的。通过内置的FIFO（First In First Out）队列来完成资源获取线程的排队工作。
AQS同步与synchronized同步是采用的两种不同的机制：  
synchronized在编译后，会在同步块的前后分别添加monitorenter和monitorexit两个字节码指令，这两个指令需要关联一个监视对象，当线程执行monitorenter指令时，需要首先获得获得监视对象的锁，即进入同步块的凭证，才能进入同步块，当线程离开同步块时，执行monitorexit指令，释放对象锁。    
AQS同步中，使用一个int类型的变量state来表示当前同步块的状态。以独占式同步为例，state的有效值为0和1，其中0表示当前同步块中没有线程，1表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断state的值是否为0，假设为0，会尝试将state修改为1，只有修改成功了之后，线程才可以进入同步块，并通过CAS操作确保同一时刻只有一个线程操作成功。当线程离开同步块时，会修改state的值为0，并唤醒等待的线程。所以在AQS同步中，线程获得锁实际上是指线程成功修改了状态变量state，而释放锁就是是指线程将状态变量置为了可修改的状态，以便其他线程可以再次尝试修改状态变量">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JUC AbstractQueuedSynchronizer"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  109 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20180406" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2018-04-05T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2018/04/06/20180406/" style="color: #736f6f;">2018-04-06</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        JUC AbstractQueuedSynchronizer
    </h1>
    
    
       <div class="title" style="padding: 5px 0px 20px 10px; color: #766;">
            ———— JDK 1.8
       </div> 
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 5.9k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 24min</font>
   
   
  
  <div class="categories">
    <a href="/categories/Java-SE/">Java SE</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/CAS/">CAS</a>   <a href="/tags/AQS/">AQS</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>队列同步器 AbstractQueuedSynchronizer（AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个int变量来表示同步状态，通过CAS操作对同步状态进行修改，确保状态的改变是安全的。通过内置的FIFO（First In First Out）队列来完成资源获取线程的排队工作。</p>
<p>AQS同步与synchronized同步是采用的两种不同的机制：  </p>
<p>synchronized在编译后，会在同步块的前后分别添加monitorenter和monitorexit两个字节码指令，这两个指令需要关联一个监视对象，当线程执行monitorenter指令时，需要首先获得获得监视对象的锁，即进入同步块的凭证，才能进入同步块，当线程离开同步块时，执行monitorexit指令，释放对象锁。    </p>
<p>AQS同步中，使用一个int类型的变量state来表示当前同步块的状态。以独占式同步为例，state的有效值为0和1，其中0表示当前同步块中没有线程，1表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断state的值是否为0，假设为0，会尝试将state修改为1，只有修改成功了之后，线程才可以进入同步块，并通过CAS操作确保同一时刻只有一个线程操作成功。当线程离开同步块时，会修改state的值为0，并唤醒等待的线程。所以<font style="color:red;">在AQS同步中，线程获得锁实际上是指线程成功修改了状态变量state，而释放锁就是是指线程将状态变量置为了可修改的状态，以便其他线程可以再次尝试修改状态变量</font><br><a id="more"></a></p>
<h3 id="1-提供方法"><a href="#1-提供方法" class="headerlink" title="1. 提供方法"></a>1. 提供方法</h3><ul>
<li>AQS是基于模板方法设计的，使用者需要继承AQS并重写指定的方法，然后在提供的模板方法中调用</li>
</ul>
<table>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td width="45%">protected boolean tryAcquire(int arg)</td>
            <td>独占式获取锁，即使用CAS操作设置同步状态</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>protected boolean tryRelease(int arg)</td>
            <td>独占式释放锁，实际也是修改同步变量</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>protected int tryAcquireShared(int arg)</td>
            <td>共享式获取锁，返回值<0表示获取失败，>0表示获取成功，=0表示获取成功，但下一个将获取失败</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>protected boolean tryReleaseShared(int arg)</td>
            <td>共享式释放锁</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>protected boolean isHeldExclusively()</td>
            <td>判断调用该方法的线程是否持有互斥锁</td>
        </tr>
    </table>

<ul>
<li>AQS提供的模板方法大概分为3类：独占式获取与释放锁，共享式获取与释放锁，以及查询同步队列中的等待线程情况</li>
</ul>
<table>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td  width="35%" >public final void acquire(int)</td>
            <td>独占式获取锁，如果当前线程成功获取锁，那么方法就返回，否则会将当前线程放入同步队列等待，该方法会调用重写的tryAcquire(int arg)来判断是否可以获得锁</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final void acquireInterruptibly(int)</td>
            <td>支持中断的独占式锁获取方式，与acquire(int)类似，但是该方法响应中断，当线程在同步队列中等待时，如果线程被中断，会抛出InterruptedException异常并返回</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final boolean tryAcquireNanos(int, long)</td>
            <td>支持超时的独占式锁获取方式，在acquireInterruptibly(int)的基础上添加了超时控制，同时支持中断和超时，如果在指定时间内没有获得锁，会返回false，获取到则返回true</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final void acquireShared(int)</td>
            <td>共享式获取锁，如果成功获取就返回，否则将当前线程放入同步队列等待，与独占式不同的是，同一时刻可以有多个线程获取</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final acquireSharedInterruptibly(int)</td>
            <td>支持中断的共享式获取锁，与上面类似</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final tryAcquireSharedNanos(int, long)</td>
            <td>支持超时的共享式获取锁，也与上面类似</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final boolean release(int)</td>
            <td>独占式释放锁，该方法会在释放锁后，将同步队列中第一个等待节点唤醒</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final boolean releaseShared(int)</td>
            <td>共享式释放锁</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td >public final Collection getQueuedThreads()</td>
            <td>获取同步队列中等待的线程集合</td>
        </tr>
    </table>


<h3 id="2-CAS操作-amp-unsafe支持"><a href="#2-CAS操作-amp-unsafe支持" class="headerlink" title="2. CAS操作 &amp; unsafe支持"></a>2. CAS操作 &amp; unsafe支持</h3><p>CAS（Compare and Swap），即比较并交换，通过底层硬件平台的特性，实现原子性操作。其涉及到3个操作数，内存地址V，旧的期望值A，修改的新值B，当且仅当内存V中的值和预期值A相同时，才将值修改为B，否则返回失败。</p>
<p>unsafe提供了一些基于CAS操作的api支持，参考笔记[<a href="https://shanhm1991.github.io/2017/06/06/20170606/#2-6-CAS">java. Unsafe</a>]，这里的CAS操作被用来修改当前<code>AbstractQueuedSynchronizer</code>实例以及<code>Node</code>对象中的属性值，根据传入的对象以及字段的偏移地址便可以定位到属性的内存地址，然后比较并交换对应的值</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("state"));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("head"));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("tail"));</span><br><span class="line">		</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("waitStatus"));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("next"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-同步队列"><a href="#3-同步队列" class="headerlink" title="3. 同步队列"></a>3. 同步队列</h3><p>AQS内部依赖一个同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态等信息构造成一个节点Node并加入同步队列，同时阻塞当前线程，当同步状态释放时，会把队列中第一个等待节点Node1线程唤醒，使其再次尝试获取同步状态</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node(); <span class="comment">// 表示共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; <span class="comment">// 表示独占模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程等待状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 关联的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 关联的线程状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前后结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; <span class="comment">// 指向下一个在某个条件上等待的节点，或者指向SHARE节点，表明当前处于共享模式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125; <span class="comment">// 作为初始化头结点或者共享标志 </span></span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; <span class="comment">// 只有addWaiter调用，mode=EXCLUSIVE</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于节点中线程的4种状态：</p>
<table>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>0</td>
            <td>初始状态，节点在释放锁会将自己状态置为0，表示自己的后继节点不需要阻塞</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td width="20%">CANCELED：1</td>
            <td>获取锁异常的线程会将节点置为CANCELED，并从链表中删除</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>SIGNAL：-1</td>
            <td>表示当前节点的后继节点需要阻塞，它由后继节点在尝试获取锁失败时设置</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>CONDITION：-2</td>
            <td>表明当前节点在条件队列中，因为等待某个条件而被阻塞</td>
        </tr>
        <tr style="border-bottom:#cccccc solid 1px;">
            <td>PROPAGATE：-3</td>
            <td>共享模式中，可以理解成是线程释放资源时没能执行唤醒，从而委托给获取资源的线程的一个状态标志</td>
        </tr>
    </table>

<h3 id="4-主要实现"><a href="#4-主要实现" class="headerlink" title="4. 主要实现"></a>4. 主要实现</h3><h4 id="4-1-独占锁的获取和释放"><a href="#4-1-独占锁的获取和释放" class="headerlink" title="4.1. 独占锁的获取和释放"></a>4.1. 独占锁的获取和释放</h4><ol>
<li><p>首先尝试获取锁<code>tryAcquire</code>，比如将状态0改为状态1，交给子类实现；</p>
</li>
<li><p>如果获取失败，则addWaiter创建节点并追加到队列尾部，<font style="color:red;">从链表的角度可以将追加过程看成两个原子动作，第一步让新节点指向当前tail，并将新节点设置为tail，第二步让原先的tail节点指向新节点</font>，然后进入acquireQueued，判断是否再次尝试获取，以及是否进行阻塞</p>
</li>
<li><p>如果阻塞是由于中断而退出，那么通过selfInterrupt()来恢复中断请求。要注意的是，<font style="color:red;">一旦节点线程进入了阻塞，将不可能自己醒来，所以已经获得锁的线程在执行完成时，务必主动进行释放锁并唤醒帮忙唤醒阻塞的线程</font></p>
</li>
</ol>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line marked">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail; </span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 首先尝试一下</span></span><br><span class="line">        node.prev = pred; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 如果尝试失败，则交给enq进行循环重试</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环尝试将当前节点添加到链表结尾，直至成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 设置头节点，表示当前已经获取到锁的线程</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 将自己追加到链表末尾</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前驱节点是head，则尝试获取</span></span><br><span class="line">                setHead(node); <span class="comment">// 如果获取成功，则将当前节点置为head节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted; </span><br><span class="line">            &#125;</span><br><span class="line marked">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)  <span class="comment">// 如果tryAcquire异常，则通过if分支取消</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldParkAfterFailedAcquire检查是否应该对线程进行阻塞，如果是则调用parkAndCheckInterrupt挂起线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 如果前驱节点为SIGNAL，则对当前节点进行阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则本轮不对当前线程进行阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果前驱为CANCELED，则向前删除所有状态为CANCELED的节点，再次进入for循环便走else分支</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前驱不是SIGNAL或CANCELED，则将其状态置为SIGNAL，再次进入for循环将会对当前线程进行阻塞</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对当前线程进行阻塞，并在退出阻塞时保留中断状态 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于获取锁流程，可以画一个简单的流程图进行说明：</p>
<p><img src="/img/20180406/20180406.1.jpg" alt=""> </p>
<p>如果tryAcquire获取锁异常，则进行取消，即将自己状态置为CANCELLED，并进行删除，如果自身是头节点则唤醒后继节点</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//  首先将node关联的线程对象置为空</span></span><br><span class="line">    Node pred = node.prev; <span class="comment">// 删除node前面所有状态为CANCELED的节点，直至出现状态不为CANCELED的节点，记为pred</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">		</span><br><span class="line">    Node predNext = pred.next; <span class="comment">// 将pred的后继节点记为predNext</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 将node状态置为CANCELLED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node是当前尾节点，尝试将尾节点置为pred，并删除node自己</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 如果pred不是头结点，同时线程不为空且状态为SIGNAL，那么尝试将pred的后继节点改为node的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head </span><br><span class="line">                &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL </span><br><span class="line">                         || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) </span><br><span class="line">                &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 否则唤醒后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>独占模式下释放锁，是没有其他线程竞争的，所以处理会简单一些。首先尝试释放锁，如果失败就直接返回（失败不是因为多线程竞争，而是线程本身就不拥有锁），而且之前获取锁之后，首先会将自身设为头节点。那么在释放时头节点一定是自己，然后先将状态改为0，并寻找需要唤醒的节点</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) </span><br><span class="line">            unparkSuccessor(h); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next; </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 将node的后继节点记为s，如果为null或状态是CANCELLED，则反过来找</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从尾部向前，找到一个不是CANCELLED的节点，记为s  </span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) </span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒节点关联的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要说一下<font style="color:red;">寻找后继需要唤醒的节点的思路</font>：由于上面追加节点的过程并非原子动作，而是分为两步，那么只能保证链表从后往前是连续的，而从前往后则有可能是断开的，因此会先尝试判断当前节点的下一个节点，如果不行，则从tail开始，向前找到最前面一个状态为非CANCELLED的节点</p>
<p>但是还有一个问题，<font style="color:red;">如果有一个线程B，在当前线程A进行tryRelease之前获取锁失败，然后却在线程A唤醒之后将节点追加到链表，那么线程B将会错过线程A的唤醒。</font>不过线程B在正式进入阻塞之前，会检查如果前驱节点是头节点，那么会再次尝试一下tryAcquire，如果能获取成功，则不会进入阻塞，这样就形成了闭环。而且链表结构没有变化，虽然线程B追加了一个节点，但是其在获取成功后又会将原来的头节点挤出链表</p>
<p>可以简要如下图所示：其中2.1在1.3之前，其它动作次序无论如何排列，都一定能得到正确的结果</p>
<p><img src="/img/20180406/20180406.2.jpg" alt=""> </p>
<p>下面假设一个场景，线程A、B、C同时获取锁，按照上面流程走一遍：</p>
<p>线程A：tryAcquire CAS(0-&gt;1)成功，继续执行代码<br>线程B：tryAcquire CAS(0-&gt;1)失败<br>线程C：tryAcquire CAS(0-&gt;1)失败<br>线程B：链表：<font style="color:red;">(2步)head = tail = node(status=0)</font><br>线程B：链表：<font style="color:red;">(2步)node(status=0) - nodeB(status=0)</font>，head = node(status=0)，tail = nodeB(status=0)<br>线程C：链表：<font style="color:red;">(2步)node(status=0) - nodeB(status=0) - nodeC(status=0)</font>，head = node(status=0)，tail = nodeC(status=0)<br>线程B：链表：<font style="color:red;">node(status=SIGNAL) - nodeB(status=0) - nodeC(status=0)</font>，head = node(status=SIGNAL)，tail = nodeC(status=0)<br>线程B：park阻塞<br>线程C：链表：<font style="color:red;">node(status=SIGNAL) - nodeB(status=SIGNAL) - nodeC(status=0)</font>，head = node(status=SIGNAL)，tail = nodeC(status=0)<br>线程C：park阻塞<br>线程A：tryRelease CAS(1-&gt;0)<br>线程A：链表：<font style="color:red;">node(status=0) - nodeB(status=SIGNAL) - nodeC(status=0)</font>，head = node(status=0)，tail = nodeC(status=0)<br>线程A：unpark(nodeB.thread)<br>线程B：tryAcquire CAS(0-&gt;1)成功<br>线程B：链表：<font style="color:red;">nodeB(status=SIGNAL) - nodeC(status=0)</font>，head = nodeB(status=SIGNAL)，tail = nodeC(status=0)<br>线程B：tryRelease CAS(1-&gt;0)<br>线程B：链表：<font style="color:red;">nodeB(status=0) - nodeC(status=0)</font>，head = nodeB(status=0)，tail = nodeC(status=0)<br>线程B：unpark(nodeC.thread)<br>线程C：tryAcquire CAS(0-&gt;1)成功<br>线程C：链表：<font style="color:red;">head = tail = nodeC(status=0)</font><br>线程C：tryRelease CAS(1-&gt;0)</p>
<h4 id="4-2-共享锁获取和释放"><a href="#4-2-共享锁获取和释放" class="headerlink" title="4.2. 共享锁获取和释放"></a>4.2. 共享锁获取和释放</h4><p>获取共享锁大体与获取独占锁的过程类似，即如果获取失败了就向链表中追加节点，只是类型为SHARED，然后如果再次尝试失败就将前驱置为SIGNAL，并进入阻塞，区别在于如果获取成功了，除了将自己置为头节点之外，还可能尝试对后继节点进行唤醒，并且唤醒具有传递性，即后面的节点同样会尝试向后进行唤醒。当然这样做主要还是考虑到共享锁在释放时的竞争问题，可能会丢失一些唤醒，具体下面会说明</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功后会检查是否需要向后进行唤醒</span></span><br><span class="line marked">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) <span class="comment">// 复用独占锁的处理</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 记住之前的head</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tryAcquireShared &gt; 0 || setHead之前的head状态&lt;0 || 当前的head即自己状态&lt;0</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line marked">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">// 除非遇到独占锁</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先不看具体实现，想一下共享锁的实现需要考虑的几个问题：</p>
<p>首先由于是共享锁，即允许有多个线程同时持有资源，那么在<font style="color:red;">释放时必然存在竞争</font>的可能。即如果同时多个线程进行释放，那么它们在唤醒时可能看到的是同一个<code>head</code>，也就可能释放了多个资源，但只唤醒了一个等待节点。 </p>
<p>于是，<code>doReleaseShared</code>中首先通过CAS与轮询，保证了就算有多个线程同时检测到状态为<code>SIGNAL</code>的<code>head</code>，也只会有一个线程可以CAS成功，即<code>head(SIGNAL -&gt; 0)</code>，然后去进行唤醒。其它线程全部打回，然后下次重新检测head。如果还能检测状态为<code>SIGNAL</code>的<code>head</code>，那一定是唤醒后的节点重置了head，这样就将出现在同一个节点上的唤醒操作错开了。</p>
<p>但是，在CAS操作<code>head(SIGNAL -&gt; 0)</code>与被唤醒的线程重新设置head之间，可能其它的线程对head状态进行了检测，并看到head状态为0，这样不管它做不做唤醒的操作都没有意义，因为即便唤醒也必然是与CAS操作成功的线程唤醒的同一个节点，也就是说这些线程在释放资源的时候将不能唤醒等待的线程，于是，希望能够<font style="color:red;">将唤醒操作委托给成功获取资源的线程</font>，但是如何让获取资源的线程感知呢？</p>
<p>同样是通过CAS操作<code>head(0 -&gt; PROPAGATE)</code>，<font style="color:red;">如果获取资源的线程在<code>setHead</code>之后，检测到之前的head状态为<code>PROPAGATE</code>，那么说明在它被唤醒之后，到<code>setHead</code>之间，一定有其它线程释放了资源，但是却没能执行唤醒操作，所以自己有义务帮忙唤醒后面的节点</font>。</p>
<p>代码实现中比较保守，其实就是宁愿存在一些不必要的唤醒也要保证队列不可能被阻塞住。网上有很多讨论关于<code>PROPAGATE</code>状态的文章，即如果没有这个状态则可能造成阻塞，但是我根据代码的逻辑反复走读，感觉即便<code>PROPAGATE</code>状态也不会造成阻塞（要是有同学觉得不对，一定帮忙指导一下），下面我简单描述一下这样说的理由：</p>
<p>首先，如果线程释放资源存在阻塞节点，那么head状态必然是<code>-1</code>。所以主要就看<code>next</code>节点的状态，如果它也是<code>-1</code>，那么它后面必然还有阻塞的节点，那么不管怎样，<code>next</code>节点在唤醒时一定会唤醒它的后继节点，因为它在<code>setHead</code>之后，将会看到自己当前的状态为<code>-1</code>，然后将状态改为<code>0</code>并唤醒下一个节点，即便没有检测到状态<code>-1</code>，也必然是由其它释放资源的线程帮忙做了这件事 </p>
<p><img src="/img/20180406/20180406.3.jpg" alt=""> </p>
<p>下面再看下next的状态为0的情况，假设所有的资源都已被持有，并且只有一个阻塞节点，然后有一个线程释放资源并唤醒阻塞节点，阻塞节点被唤醒后将资源持有，但是在其<code>setHead</code>之前刚好有个线程D来申请资源，那么线程D将申请失败，而向链表中添加节点：</p>
<p><img src="/img/20180406/20180406.4.jpg" alt=""> </p>
<p>下面还有两个动作比较关键：首先线程 D 在进入阻塞之前，会先将前面 next 状态置为 <code>-1</code>，然后再次进行检测如果发现前驱节点就是 <code>head</code> ，那么还会尝试获取一次。另外，当前获取资源的线程在 <code>setHead</code> 之后，如果看到自己的状态为 <code>-1</code>，那么便会尝试唤醒后继节点。所以，如果想看到线程 D 被阻塞，只能是发生在 <code>setHead</code> 之后，但这时确实也没有资源可获取，本身唤醒也应该阻塞直到有资源释放。而且这整个期间，只要有任何别的线程释放了资源，不管以怎样的动作次序，线程 D 都不会被阻塞住，可以将所有的原子动作都列出来然后逐个尝试，这里不再赘述。</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 链表中至少有两个以上节点，否则没有阻塞线程，不需要唤醒</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; </span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;  <span class="comment">// 同时检测到head状态为SIGNAL，但是竞争失败，于是回头重试</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 只有当head状态为SIGNAL时，后面才有线程阻塞，才需要唤醒</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 同时检测到head状态为0，但是委托失败了，也回头重试</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 除非检测到状态PROPAGATE，说明其它线程已经委托过了，所以自己可以放心去了   				</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果head发生变化，则重新检查新的head</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简单画一张流程图，来示意一下线程被唤醒后的主要操作，以及执行唤醒的具体过程：  </p>
<p><img src="/img/20180406/20180406.5.jpg" alt=""> </p>
<h4 id="4-3-中断"><a href="#4-3-中断" class="headerlink" title="4.3. 中断"></a>4.3. 中断</h4><p>先说一下<code>LockSupport.park(this)</code>是可以因为中断而退出的，而在AQS中是否支持中断就是看对于中断的处理，如果支持中断，就是检测到线程有中断申请就立即抛出<code>InterruptedException</code>而退出，并在退出之前执行下清理，即<code>cancelAcquire</code>，否则就像上面一样只是记录下中断请求，然后一直等到获取资源成功后，再恢复线程的中断。</p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line marked">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line marked">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-超时"><a href="#4-4-超时" class="headerlink" title="4.4. 超时"></a>4.4. 超时</h4><p>超时是在中断的基础上加了一层时间限制，当然首先也是依赖于<code>LockSupport.parkNanos(this, nanosTimeout)</code>的支持，如果检测到超时，则直接放弃获取锁，执行清理<code>cancelAcquire</code></p>
<figure class="highlight java"><figcaption><span class="caption">java.util.concurrent.locks.AbstractQueuedSynchronizer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line marked">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line marked">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line marked">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line marked">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line marked">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line marked">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><strong>参考：</strong></p>
<ol>
<li><a href="https://www.zhihu.com/question/50724462" target="_blank" rel="noopener">https://www.zhihu.com/question/50724462</a></li>
<li><a href="https://blog.csdn.net/anlian523/article/details/106319538" target="_blank" rel="noopener">https://blog.csdn.net/anlian523/article/details/106319538</a></li>
<li><a href="https://blog.csdn.net/ThinkWon/article/details/102469112" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/102469112</a> </li>
<li><a href="https://zhuanlan.zhihu.com/p/91408261" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91408261</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1706109" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1706109</a></li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2018/04/07/20180407/">
		    JUC Thread（TODO）
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2018/04/05/20180405/">
		    JUC FutureTask
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/Java-SE/">Java SE</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/CAS/">CAS</a>   <a href="/tags/AQS/">AQS</a>
  </div>


         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
    $("#xx_ul").click(function(){ $("#xx_li").toggle(); });
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-提供方法"><span class="toc-text">1. 提供方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CAS操作-amp-unsafe支持"><span class="toc-text">2. CAS操作 &amp; unsafe支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-同步队列"><span class="toc-text">3. 同步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-主要实现"><span class="toc-text">4. 主要实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-独占锁的获取和释放"><span class="toc-text">4.1. 独占锁的获取和释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-共享锁获取和释放"><span class="toc-text">4.2. 共享锁获取和释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-中断"><span class="toc-text">4.3. 中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-超时"><span class="toc-text">4.4. 超时</span></a></li></ol></li></ol>
</div>





  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2023 &nbsp;&nbsp; shanhm1991 &nbsp;&nbsp; version@1.0.0 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
