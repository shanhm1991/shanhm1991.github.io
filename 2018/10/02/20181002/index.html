<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>《深入理解Java虚拟机》 类 &amp; 加载 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="类加载，即把描述类的字节数据（class文件）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。与那些编译时需要链接的语言不同，java中类型的加载、链接和初始化都在运行期间完成，这种策略虽然在类加载时增加了一些性能开销，但是为java应用程序提供了高度的灵活性，Java能够动态扩展的语言特性就是依赖运行期动态加载和动态连接这些特点来实现的。
比如，编写一个面向接口的应用程序，可以等到运行时再指定其实现类。用户可以通过Java预定义或自定义的加载器，让一个本地应用程序在运行时从网络或其它地方加载一个二进制流作为程序代码的一部分。这种组装应用程序的方式已广泛应用于Java程序之中，从最基础的Applet、JSP到相对复杂的OSGI。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《深入理解Java虚拟机》 类 &amp; 加载"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  117 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20181002" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2018-10-01T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2018/10/02/20181002/" style="color: #736f6f;">2018-10-02</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        《深入理解Java虚拟机》 类 &amp; 加载
    </h1>
    
    
       <div class="title" style="padding: 5px 0px 20px 10px; color: #766;">
            ———— JDK 1.7
       </div> 
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 6.6k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 26min</font>
   
   
  
  <div class="categories">
    <a href="/categories/深入理解Java虚拟机/">深入理解Java虚拟机</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/class/">class</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>类加载，即把描述类的字节数据（class文件）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。与那些编译时需要链接的语言不同，java中类型的加载、链接和初始化都在运行期间完成，这种策略虽然在类加载时增加了一些性能开销，但是为java应用程序提供了高度的灵活性，<font color="#E51508">Java能够动态扩展的语言特性</font>就是依赖<font color="#E51508">运行期动态加载</font>和<font color="#E51508">动态连接</font>这些特点来实现的。</p>
<p>比如，编写一个面向接口的应用程序，可以等到运行时再指定其实现类。用户可以通过Java预定义或自定义的加载器，让一个本地应用程序在运行时从网络或其它地方加载一个二进制流作为程序代码的一部分。这种组装应用程序的方式已广泛应用于Java程序之中，从最基础的Applet、JSP到相对复杂的OSGI。<br><a id="more"></a></p>
<h3 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1. 类加载时机"></a>1. 类加载时机</h3><p>在虚拟机规范中，严格定义了只有以下5种情况，才对类进行初始化：</p>
<ul>
<li>遇到<code>new</code>,<code>getstatic</code>,<code>putstatic</code>,<code>invokestatic</code>指令时，即当实例化对象、读取或设置静态字段、以及调用类静态方法时；</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时；</li>
<li>初始化一个类时，其父类没有初始化时；</li>
<li>虚拟机启动时，<code>main</code>方法所在的主类；</li>
<li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是REF_getstatic，REF_putstatic，REF_invokestatic的方法句柄，则初始化这些句柄所对应的类；</li>
</ul>
<p>某些情况下，对应静态字段的引用并不会触发类的初始化，比如下面定义的两个类：</p>
<figure class="highlight java"><figcaption><span class="caption">SurperClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurperClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"str"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SurperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span class="caption">SubClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SurperClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若执行<code>Object obj = SubClass.obj;</code>，只会初始化<code>SurperClass</code>，因为<font color="#E51508">对于静态字段，只有直接定义这个字段的类才会被初始化</font></p>
</li>
<li><p>若执行<code>String str = SubClass.str;</code>，那么都不会初始化，因为在<font color="#E51508">编译阶段通过常量传播优化，常量的值已经存储到了目标类的常量池中</font>，因此，在实际执行时并没有符号引用指向<code>SurperClass</code></p>
</li>
<li><p>如果执行<code>SurperClass[] array = new SurperClass[10];</code>，则也不会初始化，这里<font color="#E51508">实际初始化的是一个由虚拟机自动生成的数组类，其直接继承于<code>java.lang.Object</code>的子类，并通过指令<code>newarray</code>触发</font></p>
</li>
</ul>
<h3 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，其整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，7个阶段。其中验证、准备、解析可以统称为连接</p>
<p><img src="/img/20181002/20181002.1.jpg" alt=""></p>
<p>对于整个加载过程，可以如上图所示，但是对于解析，其在某些情况下可以在初始化阶段之后进行，这样做是为了支持Java语言的运行时绑定。另外，上图只是表示这些阶段开始的先后顺序，实际情况可能是交叉混合进行的，比如在一个阶段的执行过程中激活调用了另一个阶段。</p>
<h4 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1. 加载"></a>2.1. 加载</h4><p>类加载阶段，将虚拟机外部的class文件按照虚拟机所需的格式存储到方法区，具体需要完成3件事情：</p>
<ol>
<li>通过一个类的全限定名获取定义该类的二进制字节流；</li>
<li>将字节流代表的静态存储结构转换为方法区的运行时数据结构；</li>
<li>在方法区中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口；</li>
</ol>
<h4 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2. 验证"></a>2.2. 验证</h4><p>验证是连接阶段的第一步，目的是保证Class文件的字节流包含的信息符合当前虚拟机的要求，保证输入的字节流能被正确解析并存储于方法区，主要包括4个阶段：</p>
<ol>
<li>文件格式验证，验证字节流是否符合Class文件的格式规范，并且能当前被虚拟机处理；</li>
<li>元数据验证，对类的元数据信息进行语义分析，保证不存在不符合Java语言规范的元数据；</li>
<li>字节码验证，通过数据流和控制流分析程序语义是否合法，对类的方法体进行校验，保证方法运行时不会危害虚拟机；</li>
<li>符号引用验证，虚拟机将符号引用转换为直接引用的时候，对常量池中各种符号引用进行校验；</li>
</ol>
<h4 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3. 准备"></a>2.3. 准备</h4><p>准备阶段即正式为类变量（即static修饰的变量，不包括实例变量）<font color="#E51508">分配内存并设置类变量初始值</font>的阶段。这些内存在方法区进行分配，这里设置的初始值一般是数据类型的零值，除非变量使用<code>final</code>修饰</p>
<h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4. 解析"></a>2.4. 解析</h4><p>解析就是虚拟机<font color="#E51508">将常量池内的符号引用替换为直接引用的过程，可以理解为对符合引用的解析</font></p>
<ul>
<li><strong>符号引用：</strong>以一组符号来描述所引用的目标，符号可以上任何形式的字面量，只要使用时能无歧义地定位到目标即可；   </li>
<li><strong>直接引用：</strong>可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，总之引用的目标必定已经在内存中存在；</li>
</ul>
<p>虚拟机规范并未对什么时候进行解析有规定，只要求在执行<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokeestatic</code>、<code>involevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putstatic</code>和<code>putfield</code>这16个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用解析。</p>
<p>其中，除了<code>invokedynamic</code>之外，虚拟机可以对指令第一次解析的结果进行缓存，即在运行时常量池中记录直接引用，并标识为已解析状态，从而避免解析动作重复进行。而<font color="#E51508"><code>invokedynamic</code>的本意用于动态语言支持（多态），必须等到程序实际运行到这条指令时才进行解析</font></p>
<p>至于具体解析主要针对：类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符，这7类符号引用进行解析  </p>
<ul>
<li><strong>类或接口的解析</strong>  </li>
</ul>
<p>假设当前代码所处的类为<code>D</code>，如果想把一个从未解析过的符号引用<code>N</code>解析到一个类或接口<code>C</code>的直接引用，可以将过程分为3步：</p>
<ol>
<li>如果<code>C</code>不是一个数组类型，虚拟机将把符号引用<code>N</code>的全限定类名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。在加载的过程中由于需要验证，可能又会触发其他类的加载，一旦加载过程出现错误，则解析失败；</li>
<li>如果<code>C</code>是一个数组类型，数组元素也是对象类型的话，那么<code>N</code>的描述符将会是类似<code>[Ljava/lang/Integer</code>的形式。那么，会按照第一步的规则加载数组元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象；</li>
<li>如果前面的步骤都没有出现错误，在解析完成前还需要进行符号引用的验证，确认<code>D</code>是否具有对<code>C</code>的访问权限，如果没有，则抛出<code>java.lang.IllegalAccessEroor</code>异常；</li>
</ol>
<ul>
<li><strong>字段解析</strong></li>
</ul>
<p>要解析一个未解析过的字段的符号引用，首先要对字段表内的<code>class_index</code>项索引的<code>CONSTANT_Class_info</code>符号引用解析，也就是字段所属的类或接口的符号引用。</p>
<p>如果在解析这个类或接口的符号引用出现异常，则字段解析的失败。如果这个类或接口解析成功，将这个字段所属的类或接口用<code>C</code>表示，然后对<code>C</code>进行后续的字段搜索</p>
<ol>
<li>如果<code>C</code>本身就包含了简单名称和字段描述符都与目标字段相同的字段，则返回这个字段的直接引用，查找结束；</li>
<li>否则，如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索每个接口和它的父接口，然后按照步骤1去查找；</li>
<li>否则，如果<code>C</code>不是<code>object</code>类的话，按照继承关系从下往上递归搜索其父类，然后按照步骤1去查找；</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常；</li>
</ol>
<ul>
<li><strong>类方法解析</strong></li>
</ul>
<p>与字段解析一样，第一步也是先解析出类方法表的<code>class_index</code>索引，也就是方法所属类或接口的符号引用。如果解析成功，用<code>C</code>表示这个类，接下来虚拟机按照以下步骤进行类方法的搜索：</p>
<ol>
<li>在类<code>C</code>中查找是否有简单名称和描述符都与目标匹配的方法，如果有返回这个方法的直接引用，查找结束；</li>
<li>否则在类<code>C</code>的父类中递归查找；</li>
<li>否则在类<code>C</code>的接口或父接口中查找；</li>
<li>否则查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常；</li>
</ol>
<h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5. 初始化"></a>2.5. 初始化</h4><p>在类加载过程中，除了在加载阶段可以自定义类加载器参与类的加载过程外，其余的步骤完全由虚拟机主导和控制，直到初始化阶段，才真正开始执行类中定义的Java代码。</p>
<p>在准备阶段，变量已经被赋值为类型的零值，而在初始化阶段，则根据程序制定的主观计划去初始化类变量和其他资源，即初始化阶段是执行类构造器方法<code>&lt;cinit&gt;()</code>的过程。</p>
<p><font color="#E51508"><code>&lt;cinit&gt;()</code>是由编译器自动收集类中的所有类变量的赋值操作和静态语句块<code>static{}</code>中的所有语句合并而生的</font>，因此，它不是必须的。<br>静态语句块只能访问到定义在静态语句前的变量，对于定义在它之后的变量，只能赋值而不能访问。</p>
<p>另外，虚拟机会保证在执行子类<code>&lt;cinit&gt;()</code>之前，父类<code>&lt;cinit&gt;()</code>已经执行完毕。不过，执行接口的<code>&lt;cinit&gt;()</code>不需要先执行父接口的<code>&lt;cinit&gt;()</code>，接口实现类在初始化时也一样不需要执行父接口的<code>&lt;cinit&gt;()</code>，只有当使用父接口中定义的变量时，父接口才会初始化。 </p>
<p>特别的，<font color="#E51508">虚拟机会保证一个类的<code>&lt;cinit&gt;()</code>在多线程环境中被正确的加锁、同步</font>。如果多线程同时去初始化一个类，那么只会有一个线程执行，其他线程都需要阻塞等待，直到初始化完毕。要注意的是，其他线程虽然会被阻塞，但在执行<code>&lt;cinit&gt;()</code>的线程退出之后，它们也不会再进入<code>&lt;cinit&gt;()</code>方法，即同一个类加载器下，一个类型只会初始化一次。</p>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>虚拟机设计者将类加载过程中的加载动作放到虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块便称为类加载器</p>
<p>因此，类加载器的任务便是根据一个类的全限定名来读取此类的二进制字节流到Jvm中，然后转换为一个与目标类对应的<code>java.lang.Class</code>对象实例。<font color="#E51508">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中唯一性，每一个类加载器，都拥有一个独立的类名称空间</font>。</p>
<p>虚拟机提供了3种类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap）</li>
</ul>
<p>启动类加载器主要加载的是Jvm自身需要的类，这个类加载器使用C++语言实现，是虚拟机自身的一部分，它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中，<font color="#E51508">注意虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的，另外，出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</font>。</p>
<ul>
<li>扩展类加载器（ExtClassLoader）</li>
</ul>
<p>它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录或由<code>-Djava.ext.dir</code>指定路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
<ul>
<li>应用程序类加载器（AppClassLoader）</li>
</ul>
<p>它负责加载<code>classpath</code>路径下的类库，可以通过<code>ClassLoader.getSystemClassLoader()</code>获取，一般情况下，该类加载器是程序中默认的类加载器</p>
<h4 id="3-1-双亲委派模型"><a href="#3-1-双亲委派模型" class="headerlink" title="3.1. 双亲委派模型"></a>3.1. 双亲委派模型</h4><p>在一般程序开发中，类的加载都由以上3种类加载器相互配合执行的，当然，也可以自定义类加载器。它们以组合的方式组织成父子关系，称为双亲委派模型</p>
<p><img src="/img/20181002/20181002.2.jpg" alt=""></p>
<p>双亲委派模型在Java 1.2后引入，其思路是，如果一个类加载器收到了类加载请求，它并不会自己去加载，而是先把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，最终将到达顶层的启动类加载器。然后，如果父类加载器可以完成类加载任务，就成功返回，而如果父类加载器无法完成此加载任务，则由子加载器尝试自己去加载。</p>
<p>使用双亲委派的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以<font color="#E51508">避免类的重复加载</font>，当父亲已经加载了该类时，就没有必要子<code>ClassLoader</code>再加载一次了。其次<font color="#E51508">考虑到安全因素，java核心api中定义的类也不会被随意替换</font>，假设通过网络传递一个名为<code>java.lang.Integer</code>的类，通过双亲委托模式传递到启动类加载器，而启动类加载器发现该类已被加载，则直接返回已加载过的<code>Integer.class</code>，这样便可以防止核心API库被篡改。</p>
<ul>
<li>线程上下文加载器 ContextClassLoader</li>
</ul>
<p>双亲委派可以很好的解决各个类加载器加载的类的统一问题，但<font color="#E51508">如果父加载器加载的类想去调用子加载器加载的类</font>，那么将出现问题。比如java中提供的一些spi（service provider interface），当调用具体的实现时，如果这些具体实现类的class直接默认使用当前类<code>Caller</code>的加载器（即spi的加载器BootstrapClassLoader）进行加载，那么肯定失败。</p>
<p>因此，为了解决这个问题，java设计团队引入了一个不太优雅的设计：<code>ContextClassLoader</code>。可以从<code>currentThread</code>中获取，java在启动时会将其置为应用类加载器<code>AppClassLoader</code>，后面子线程在创建时会默认设置为父线程的上下文加载器，所以，spi在调用时便可以通过显示的指定类加载器来解决问题。</p>
<p>其实，<font color="#E51508">使用线程上下文类加载器相当于重置了一下加载器的起点</font>，因为spi自身的加载器起点已经很高了，它只能继续向上寻找，那肯定找不到。因此，如果它希望找到低层加载器加载的类，可以通过<code>ContextClassLoader</code>来获取到最底层的AppClassLoader，这样就能获取到<code>AppClassLoader</code>加载的实现类了。</p>
<h4 id="3-2-Launcher"><a href="#3-2-Launcher" class="headerlink" title="3.2. Launcher"></a>3.2. Launcher</h4><p><code>Launcher</code>是Java应用的入口，由Jvm创建，所以它的类加载器是<code>BootStrapClassLoade</code>。在它的构造器中，分别创建了<code>ExtClassLoader</code>和<code>AppClassLoader</code>，并将<code>AppClassLoader</code>的<code>parent</code>置为<code>ExtClassLoader</code>，以组成父子关系。另外，将线程上下文类加载器赋值为<code>AppClassLoader</code></p>
<figure class="highlight java"><figcaption><span class="caption">sun.misc.Launcher</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This class is used by the system to launch the main application</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandlerFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line marked">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line marked">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also set the context class loader for the primordial thread.</span></span><br><span class="line marked">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, install a security manager if requested</span></span><br><span class="line">        String s = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SecurityManager sm = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(s) || <span class="string">"default"</span>.equals(s)) &#123;</span><br><span class="line">                sm = <span class="keyword">new</span> java.lang.SecurityManager();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.setSecurityManager(sm);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create SecurityManager: "</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-1-ExtClassLoader"><a href="#3-2-1-ExtClassLoader" class="headerlink" title="3.2.1 ExtClassLoader"></a>3.2.1 ExtClassLoader</h5><p><code>ExtClassLoader</code>默认加载默认加载<code>JAVA_HOME/jre/lib/ext/</code>下的包，或者由<code>java.ext.dirs</code>指定的目录下的包</p>
<figure class="highlight java"><figcaption><span class="caption">sun.misc.Launcher.ExtClassLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Creates a new ExtClassLoader for the specified directories.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] getExtURLs(File[] dirs) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Vector&lt;URL&gt; urls = <span class="keyword">new</span> Vector&lt;URL&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class="line">            String[] files = dirs[i].list();</span><br><span class="line">            <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; files.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!files[j].equals(<span class="string">"meta-index"</span>)) &#123;</span><br><span class="line">                        File f = <span class="keyword">new</span> File(dirs[i], files[j]);</span><br><span class="line">                        urls.add(getFileURL(f));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        URL[] ua = <span class="keyword">new</span> URL[urls.size()];</span><br><span class="line">        urls.copyInto(ua);</span><br><span class="line">        <span class="keyword">return</span> ua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create an ExtClassLoader. The ExtClassLoader is created</span></span><br><span class="line"><span class="comment">     * within a context that limits which files it can read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line marked">        <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">            <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">            <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line marked">                            <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line marked">        String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        File[] dirs;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(s, File.pathSeparator);</span><br><span class="line">            <span class="keyword">int</span> count = st.countTokens();</span><br><span class="line">            dirs = <span class="keyword">new</span> File[count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                dirs[i] = <span class="keyword">new</span> File(st.nextToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dirs = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-AppClassLoader"><a href="#3-2-2-AppClassLoader" class="headerlink" title="3.2.2 AppClassLoader"></a>3.2.2 AppClassLoader</h5><p><code>AppClassLoader</code>负责加载<code>java.class.path</code>目录下class，即应用程序的实现</p>
<figure class="highlight java"><figcaption><span class="caption">sun.misc.Launcher.AppClassLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line marked">        <span class="keyword">final</span> String s = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">        <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: on bugid 4256530</span></span><br><span class="line">        <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">        <span class="comment">// a rather restrictive ACC via a call to the private method</span></span><br><span class="line">        <span class="comment">// AppClassLoader.getContext(). This proved overly restrictive</span></span><br><span class="line">        <span class="comment">// when loading  classes. Specifically it prevent</span></span><br><span class="line">        <span class="comment">// accessClassInPackage.sun.* grants from being honored.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        URL[] urls = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line marked">                        <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Creates a new AppClassLoader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(urls, parent, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Override loadClass so we can checkPackageAccess.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">            SecurityManager sm = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sm.checkPackageAccess(name.substring(<span class="number">0</span>, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">super</span>.loadClass(name, resolve));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-ClassLoader"><a href="#3-3-ClassLoader" class="headerlink" title="3.3. ClassLoader"></a>3.3. ClassLoader</h4><p>上面的<code>AppClassLoader</code>以及<code>ExtClassLoader</code>都间接继承了<code>ClassLoader</code>，其提供了一个类加载的模板方法<code>loadClass</code>，而思路就是使用的双亲委派模型。</p>
<p>它将<code>findClass</code>的过程交给子类实现，不过<code>URLClassLoader</code>就已经提供了<code>find</code>的实现，并且<code>SecureClassLoader</code>提供了安全校验的实现，所以上面的<code>AppClassLoader</code>和<code>ExtClassLoader</code>只需要指定加载路径即可。</p>
<p><img src="/img/20181002/20181002.3.jpg" alt=""></p>
<figure class="highlight java"><figcaption><span class="caption">java.lang.ClassLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); <span class="comment">// 检查是否已经加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 尝试委托给父加载器进行加载，一直到启动类加载器</span></span><br><span class="line marked">            <span class="keyword">try</span> &#123;</span><br><span class="line marked">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line marked">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line marked">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line marked">                    c = findBootstrapClassOrNull(name);</span><br><span class="line marked">                &#125;</span><br><span class="line marked">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line marked">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line marked">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line marked">            &#125;</span><br><span class="line marked">            </span><br><span class="line marked">            <span class="comment">// 如果parent加载不到，则自己进行加载</span></span><br><span class="line marked">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line marked">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line marked">                c = findClass(name); </span><br><span class="line marked">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line marked">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line marked">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line marked">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line marked">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加载之后是否进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于自定义的类加载器，可以直接通过重写<code>findClass</code>来加载自己的类型信息。另外，<font color="#E51508">为了保证<code>loadClass</code>中双亲委派方式加载的进行，类加载器要求在初始化时必须指定一个父加载器<code>parent</code>，如果是无参构造，则默认指定为</font><code>AppClassLoader</code></p>
<figure class="highlight java"><figcaption><span class="caption">java.lang.ClassLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//systemClassLoader即应用程序类加载器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sclSet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line marked">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line marked">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        </span><br><span class="line marked">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;          </span><br><span class="line marked">            scl = l.getClassLoader(); <span class="comment">//从Launcher唯一的实例中获取AppClassLoader唯一的实例</span></span><br><span class="line">            </span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(<span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Class常见异常"><a href="#4-Class常见异常" class="headerlink" title="4. Class常见异常"></a>4. Class常见异常</h3><ul>
<li>ClassNotFoundException</li>
</ul>
<p><code>ClassNotFoundException</code>通常发生在显示加载类的时候，出现这个异常也很好理解，就是当Jvm加载某个类时发现class文件或字节码不存在。办法就是检查当前<code>classpath</code>路径下是否存在指定文件，至于<code>classpath</code>路径可以通过已加载的类来获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">""</span>).toString();</span><br></pre></td></tr></table></figure>
<p>常见的显示加载一个类的方式有：<code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>、或者<code>ClassLoader.findSystemClass()</code></p>
<ul>
<li>NoClassDefFoundError</li>
</ul>
<p>Jvm规范中描述了出现<code>NoClassDefFoundError</code>的可能情况是使用<code>new</code>关键字、属性引用某个类、继承某个接口或类、以及方法的某个参数引用某个类等，其实概括起来就是<font color="#E51508">当引用某个类时发现不存在</font>，解决办法是确保每个类引用的类都在当前<code>classpath</code>目录下面。</p>
<ul>
<li>UnsatisfiedLinkError</li>
</ul>
<p><code>UnsatisfiedLinkError</code>通常是在解析<code>native</code>标识的方法时，Jvm找不到对应的本机库文件。如果出现的话，通常是在Jvm启动的时候，可能是不小心将Jvm类库中的某个<code>lib</code>删除了。</p>
<ul>
<li>ClassCastException</li>
</ul>
<p>类型转换错误也很常见，就是不满足子类代替父类的原则，一般可以通过泛型进行编译期检查或者转换前的类型判断来避免，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(<span class="string">"a"</span>, <span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        System.out.println((<span class="keyword">int</span>)m.get(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ExceptionInInitializerError</li>
</ul>
<p>类初始化错误就是发生在上面类加载过程的1.5阶段，即给类变量赋值时，或者执行静态语句块时发现的错误，如果错误不是Error或者其某个子类，那么就会创建抛出一个ExceptionInInitializerError，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            m.put(<span class="string">"a"</span>, <span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        System.out.println((<span class="keyword">int</span>)m.get(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at org.springframework.hs.Test$1.&lt;init&gt;(Test.java:14)</span><br><span class="line">    at org.springframework.hs.Test.&lt;clinit&gt;(Test.java:12)</span><br></pre></td></tr></table></figure>
<h3 id="5-自定义类加载器"><a href="#5-自定义类加载器" class="headerlink" title="5. 自定义类加载器"></a>5. 自定义类加载器</h3><p>某些场景下可能希望自定义类加载器</p>
<ul>
<li>如果想加载自定义路径下的<code>class</code>，即这些<code>class</code>不在<code>classPath</code>下面，那么可以自定义<code>ClassLoader</code>来定义如何找<code>class</code></li>
</ul>
<p>下面按照标准双亲委派的模式定义一个简单的加载器，加载指定路径下的<code>class</code>文件</p>
<figure class="highlight java"><figcaption><span class="caption">PathClassLoader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123; </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = getBytes(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getBytes(String className) <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">        String path = classPath + File.separatorChar + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>; </span><br><span class="line">        <span class="keyword">try</span>(InputStream input = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((num = input.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                stream.write(buffer, <span class="number">0</span>, num); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载入口还是<code>loadClass</code>，因此如果class已经加载或已经可以由父加载器加载则跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader loader = <span class="keyword">new</span> PathClassLoader(<span class="string">"E:/"</span>);</span><br><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">"org.springframework.hs.User"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于加载网络传输的class，可能希望加密处理，那么可以自定义ClassLoader在加载之前进行解密操作</p>
</li>
<li><p>如果希望重新加载被修改过的class，即实现类的热部署，那么可以自定义ClassLoader，每次创建一个新的ClassLoader实例进行加载</p>
</li>
</ul>
<p>Java应用有一个痛点，就是如果修改一个类，那么必须要重启。所以，是否可以进行类的动态加载而不需要重启Jvm呢，答案是否定的，因为这违反了Jvm的工作机制。 Java的一个优势正是其基于共享对象的机制，通过保存并持有对象的状态而省去类信息的重复创建与回收。一旦对象被创建，则可以被其它对象持有和利用。</p>
<p>如果动态加载一个类到Jvm，并创建其新的实例对象，那么如何做到平滑更新持有这个对象的对象中的引用呢？这几乎是不可能的，因为在Jvm的设计原则中，对象的引用关系只有对象的创建者持有和使用，Jvm无法知道甚至干预对象的引用关系。<br>如果一定要动态加载，那么可以避免对象状态的保存，就是不让对象被其它地方持有或者引用，对象被创建使用后就被释放掉，下载修改并重写加载后，对象也就是新的了，正如Jsp就是这样实现的。</p>
<p><br><strong>参考：</strong></p>
<ol>
<li>Copyright&nbsp;&copy;《深入理解java虚拟机》</li>
<li>《深入分析 Java Web》</li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2018/10/03/20181003/">
		    《深入理解Java虚拟机》 类 &amp; Class对象/反射
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2018/10/01/20181001/">
		    《深入理解Java虚拟机》 类 &amp; class文件
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/深入理解Java虚拟机/">深入理解Java虚拟机</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/class/">class</a>
  </div>


         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
    $("#xx_ul").click(function(){ $("#xx_li").toggle(); });
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-类加载时机"><span class="toc-text">1. 类加载时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-类加载过程"><span class="toc-text">2. 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-加载"><span class="toc-text">2.1. 加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-验证"><span class="toc-text">2.2. 验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-准备"><span class="toc-text">2.3. 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-解析"><span class="toc-text">2.4. 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-初始化"><span class="toc-text">2.5. 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-类加载器"><span class="toc-text">3. 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-双亲委派模型"><span class="toc-text">3.1. 双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Launcher"><span class="toc-text">3.2. Launcher</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-ExtClassLoader"><span class="toc-text">3.2.1 ExtClassLoader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-AppClassLoader"><span class="toc-text">3.2.2 AppClassLoader</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-ClassLoader"><span class="toc-text">3.3. ClassLoader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Class常见异常"><span class="toc-text">4. Class常见异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-自定义类加载器"><span class="toc-text">5. 自定义类加载器</span></a></li></ol>
</div>





  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2024 &nbsp;&nbsp; shanhm1991 &nbsp;&nbsp; version@1.0.0 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
