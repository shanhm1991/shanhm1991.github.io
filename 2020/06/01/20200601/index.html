<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>《UNIX环境高级编程》 文件 | Echo</title>
  <meta name="author" content="shanhm1991">
  
  <meta name="description" content="Linux中所有的 I/O 设备都被抽象为文件，这样所有的输入输出都被当作对相应的文件进行读写操作。这种将设备统一映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为 Unix I/O， 使得所有的输入输出都能以一种统一的方式执行。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《UNIX环境高级编程》 文件"/>
  <meta property="og:site_name" content="Echo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Echo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-147251181-1', 'auto');
	ga('send', 'pageview');

</script>


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header id="header" class="inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="alignleft">
  <h1><a href="/">Echo</a></h1>
  <span style="color:#736f6f; height:20px;line-height:30px;">It's a long long way to go</span>
  <h2><font style="color: #736f6f;">articles:  114 &nbsp;&nbsp;&nbsp; views: <span id="busuanzi_value_site_uv"></span></font></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">Abount</a></li>
    
      <li><a href="/books">Books</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>

<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-20200601" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-05-31T16:00:00.000Z" style="margin-bottom: 10px;"><a href="/2020/06/01/20200601/" style="color: #736f6f;">2020-06-01</a></time>
      
      

  
  
    <h1 class="p-name title" itemprop="headline name">
        《UNIX环境高级编程》 文件
    </h1>
    
    
  
  
  


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


   <span style="line-height:35px; height:35px; ">  </span>

   <font style="color: #999;"> words: 4.8k  &nbsp;&nbsp; views: <span id="busuanzi_value_page_pv"></span> &nbsp;&nbsp; time: 19min</font>
   
   
  
  <div class="categories">
    <a href="/categories/UNIX环境高级编程/">UNIX环境高级编程</a>
  </div>


   
   
  
  <div class="tags">
    <a href="/tags/I-O/">I/O</a>
  </div>


   
   <hr style="background-color: #ddd; height:1px; border:none;" /><br>
   


    </header>
      
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Linux中所有的 I/O 设备都被抽象为文件，这样所有的输入输出都被当作对相应的文件进行读写操作。这种将设备统一映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为 Unix I/O， 使得所有的输入输出都能以一种统一的方式执行。<br><a id="more"></a></p>
<h3 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h3><p>对于内核而言，所有打开的文件都通过文件描述符进行引用。文件描述符是一个非负整数，当打开或创建一个文件时，内核向进程返回一个文件描述符；当读写一个文件时，也是通过文件描述符作为参数来进行系统调用。</p>
<p>在可移植操作系统接口规范POSIX.1（Portable Operating System Interface of UNIX）中，描述符<code>0</code>、<code>1</code>、<code>2</code>分别与标准输入、标准输出，标准错误关联，并作为常量定义在头文件<code>&lt;unistd.h&gt;</code>中，分别为<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>、<code>STDERR_FILENO</code></p>
<h4 id="1-1-基本函数"><a href="#1-1-基本函数" class="headerlink" title="1.1. 基本函数"></a>1.1. 基本函数</h4><h5 id="1-1-1-open、openat"><a href="#1-1-1-open、openat" class="headerlink" title="1.1.1. open、openat"></a>1.1.1. open、openat</h5><figure class="highlight c"><figcaption><span class="caption">fcnt1.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功，返回文件描述符，出错则返回-1。参数<code>path</code>为要打开或创建的文件名；参数<code>fd</code>用来说明当<code>path</code>为相对路径时的起始地址；参数<code>oflag</code>用来说明操作的选项，用一个或多个常量进行或运算构成，至于常量则定义在<code>fcnt1.h</code>中<br>    <table width=100%>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_RDONLY </td>
            <td>：只读打开</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_WRONLY </td>
            <td>：只写打开</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_RDWR </td>
            <td>：读写打开</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_EXEC </td>
            <td>：只执行打开</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_SEARCH </td>
            <td>：只搜索打开（应用于目录）</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td></td>
            <td><font color="red">上述5个常量有且只能指定一个，下面是可选常量</font></td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_APPEND </td>
            <td>：写入时追加到文件末尾</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_CLOEXEC </td>
            <td>：设置常量O_CLOEXEC设置为文件描述符标志</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_CREAT </td>
            <td>：若文件不存在则创建，此时需要指定新文件的访问权限mode</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_DIRECTORY </td>
            <td>：如果path引用的不是目录，则出错</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_EXCL </td>
            <td>：若同时指定O_CREAT，而文件已存在则出错，不存在则创建，因此可以用来构建原子操作</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_NOCTTY </td>
            <td>：若path引用的是终端设备，则不将该设备分配为此进程的控制终端</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_NOFOLLOW </td>
            <td>：若path引用的是符号链接，则出错</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_NONBLOCK </td>
            <td>：若path引用的FIFO、块特殊文件或字符特殊文件，则将打开后续的I/O操作设置为非阻塞方式</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_TRUNC </td>
            <td>：如果文件存在，而且为只写或读写打开，则将其长度截断为0</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_SYNC </td>
            <td>：使每次write等待物理I/O操作完成，包括由write引起的文件属性更新所需的I/O</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> O_DSYNC </td>
            <td>：使每次write等待物理I/O操作完成，但不需要等待文件属性的更新</td>
        </tr>
        <tr>
            <td> O_RSYNC </td>
            <td>：使以文件描述符作为参数进行的read操作等待，直到所有对文件同一部分挂起的所有写操作全部完成</td>
        </tr>
    </table></p>
<h5 id="1-1-2-creat"><a href="#1-1-2-creat" class="headerlink" title="1.1.2. creat"></a>1.1.2. creat</h5><figure class="highlight c"><figcaption><span class="caption">fcnt1.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若成功则返回文件描述符，出错则返回-1，可以等效于<code>open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</code>     </p>
<p><code>create</code>的不足之处是它以只写方式打开所创建的文件，如果要读取创建的文件，则在创建之后要先<code>close</code>，然后在<code>open</code>，当然也可以直接使用<code>open(path, O_RDWR|O_CREAT|O_TRUNC, mode);</code></p>
<h5 id="1-1-3-close"><a href="#1-1-3-close" class="headerlink" title="1.1.3. close"></a>1.1.3. close</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成功返回0，出错则返回-1。关闭一个文件时会释放当前进程加在该文件上的所有记录锁，而当一个进程终止时，内核也会关闭所有它打开的文件。</p>
<h5 id="1-1-4-lseek"><a href="#1-1-4-lseek" class="headerlink" title="1.1.4. lseek"></a>1.1.4. lseek</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p>每个打开文件都有一个偏移量属性，用以计算距离文件开始处的字节数。通常读写操作都是从当前文件偏移量开始，并使偏移量增加所读写的字节数。当打开一个文件时，如果不指定<code>O_APPEND</code>属性，偏移量则默认设置为0。    </p>
<p>若成功则返回新的文件偏移量，出错则返回-1，其中参数<code>offset</code>的解释与<code>whence</code>相关：<br>    <table width=100%>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> whence = SEEK_SET </td>
            <td>：将文件的偏移量设置为距文件开始处offset个字节</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> whence = SEEK_CUR </td>
            <td>：将文件的偏移量设置为当前偏移量加上offset，offset可为负</td>
        </tr>
        <tr>
            <td> whence = SEEK_END </td>
            <td>：将文件的偏移量设置为文件长度加上offset，offset可为负</td>
        </tr>
    </table></p>
<p>因此，通过<code>curr_offset = lseek(fd, 0, SEEK_CUR)</code>可以获取当前打开文件的偏移量，还可以用来确定当前文件是否支持设置偏移量，如果描述符指向的是一个管道、FIFO或网络套接字，则<code>lseek</code>返回<code>-1</code></p>
<p><code>lseek</code>仅将当前文件偏移量记录在内核中，并不会引起任何I/O操作，该偏移量将用于下一个读写操作。文件偏移量可以大于当前文件长度，然后在下一次写入时将加长该文件，并在文件中构成一个空洞，这是允许的，但文件中没有写过的字节都被读为0，文件空洞也并不要求在磁盘上占用存储区，具体处理方式与文件系统的实现有关。</p>
<h5 id="1-1-5-read、write"><a href="#1-1-5-read、write" class="headerlink" title="1.1.5. read、write"></a>1.1.5. read、write</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>
<p><code>read</code>成功则返回读到的字节数（读到文件末尾则返回0），出错则返回-1。<code>write</code>的返回值通常与nbytes值相同，否则表示出错。</p>
<h4 id="1-2-示例：cp"><a href="#1-2-示例：cp" class="headerlink" title="1.2. 示例：cp"></a>1.2. 示例：cp</h4><p>如下，通过<code>read</code>和<code>write</code>函数复制一个文件</p>
<figure class="highlight c"><figcaption><span class="caption">vim test.cp.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"write error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc test.cp.c -o cp &amp;&amp; cp test.cp.c test.cp.c.copy</span></span><br></pre></td></tr></table></figure>
<p>大多数文件系统为改善性能都会采用某种预读技术，当检测到正在进行顺序读取时，系统会试图读入比应用程序所要求的更多数据，并假设应用很快就会读取这些数据。当然理想情况是将缓存大小设置成与磁盘块长度一致，比如在Linux ext4的文件系统上，可以设置为4096。</p>
<h3 id="2-共享文件"><a href="#2-共享文件" class="headerlink" title="2. 共享文件"></a>2. 共享文件</h3><p>内核使用3种数据结构表示打开文件，它们的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响：</p>
<ul>
<li><p>每个进程在<font color="red">进程表</font>中都有一个记录项，记录项中包含一个进程打开的所有文件的<font color="red">描述符表</font>，每个描述符占用一项，<br>每一项关联一个<strong>文件描述符标志</strong>，和一个指向文件表项的指针；</p>
</li>
<li><p>内核为每个打开的文件维持一张<font color="red">文件表</font>，表中包含<strong>文件状态标志</strong>（读写、同步阻塞等）、当前文件偏移量、指向该文件v节点表项的指针；</p>
</li>
<li><p>每个打开的文件（或设备）都有一个<font color="red"><code>v</code>节点</font>结构，<code>v</code>节点中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，<code>v</code>节点中还包含了文件的<code>i</code>节点（索引节点，其中包含了文件的所有者、文件长度、指向文件实际数据在磁盘位置的指针等）。Linux并没有使用<code>v</code>节点，而是使用的通用<code>i</code>节点，但在概念上是一样的。</p>
</li>
</ul>
<p>下图展示了一个进程打开两个不同的文件，对应的3张表之间的关系。从UNIX[Thompson 1978]以来，这三张表之间的关系一直保持至今，这种关系对于在不同进程之间共享文件的方式非常重要。</p>
<p><img src="/img/20200601/20200601.1.jpg" alt=""> </p>
<p>如果两个独立进程各自打开同一个文件，则有下图所示关系：</p>
<p><img src="/img/20200601/20200601.2.jpg" alt=""> </p>
<p>对于一个给定的文件只有一个<code>v</code>节点表项，但对于每个打开该文件的进程都有各自的一个文件表项（以便记录各自的偏移量），另外，也可能多个文件描述符指向同一文件表项。比如fork时，父进程、子进程对于各自的每一个打开文件描述符都共享同一个文件表项。</p>
<h4 id="2-1-基本函数"><a href="#2-1-基本函数" class="headerlink" title="2.1. 基本函数"></a>2.1. 基本函数</h4><h5 id="2-1-1-pread、pwrite"><a href="#2-1-1-pread、pwrite" class="headerlink" title="2.1.1. pread、pwrite"></a>2.1.1. pread、pwrite</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure>
<p><code>pread</code>相当于先调用<code>lseek</code>后再调用<code>read</code>操作，<code>pwrite</code>相当于先调用<code>lseek</code>后再调用<code>write</code>操作，区别在于这里是原子操作，并且不影响当前文件偏移量。</p>
<h5 id="2-1-2-dup、dup2"><a href="#2-1-2-dup、dup2" class="headerlink" title="2.1.2. dup、dup2"></a>2.1.2. dup、dup2</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>复制文件描述符，如果成功则返回新的文件描述符，出错则返回<code>-1</code>。dup2可以用fd2指定新描述符的值，如果fd2已打开，则先将其关闭。</p>
<h5 id="2-1-3-sync、fsync、fdatasync"><a href="#2-1-3-sync、fsync、fdatasync" class="headerlink" title="2.1.3. sync、fsync、fdatasync"></a>2.1.3. sync、fsync、fdatasync</h5><figure class="highlight c"><figcaption><span class="caption">unistd.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般向文件写入数据时，内核会将数据先复制到缓冲区，然后排入队列，晚些时候再写入磁盘，即延迟写。当内核复用缓冲区来存放其它数据时，它会将缓冲的数据写入磁盘，为了保证磁盘上实际数据与缓冲的内容一致，UNIX系统提供了上面几个调用来主动同步。</p>
<table>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> sync </td>
            <td>：sync只是将所有修改过的块缓冲区排入写队列，然后就返回，并不等待实际写磁盘操作结束。系统守护进程update会负责周期性（一般每隔30s）地调用sync，保证定期冲洗内核的块缓冲区</td>
        </tr>
        <tr style="border-bottom:0.01rem solid grey;">
            <td> fsync </td>
            <td>：fsync只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。fsync可用于数据库这样的应用，这种应用需要确保修改过的块立即写到磁盘上</td>
        </tr>
        <tr>
            <td> fdatasync </td>
            <td>：fdatasync类似于fsync，区别在于它只影响文件的数据部分，而不包括文件的属性</td>
        </tr>
    </table>

<h5 id="2-1-4-fcnt1"><a href="#2-1-4-fcnt1" class="headerlink" title="2.1.4. fcnt1"></a>2.1.4. fcnt1</h5><figure class="highlight c"><figcaption><span class="caption">fcnt1.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcnt1</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fcnt1</code>用于改变打开文件的属性，对应有以下5种功能：</p>
<ol>
<li>复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）</li>
<li>获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）</li>
<li>获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）</li>
<li>获取/设置异步I/O所有权（cmd = F_GETOWN 或 F_SETOWN）</li>
<li>获取/设置记录锁（cmd = F_GETLK、F_SETLK 或 F_SETLKW）</li>
</ol>
<h3 id="3-文件类型"><a href="#3-文件类型" class="headerlink" title="3. 文件类型"></a>3. 文件类型</h3><ul>
<li><p><strong>普通文件</strong>，最常用的文件类型，即包含了某种形式的数据，至于是文本数据还是二进制并无区别。但是对于可执行的二进制文件，需要遵循一种标准，以便内核能够理解其格式，以及确定程序文本和数据的加载位置；</p>
</li>
<li><p><strong>目录文件</strong>，这种文件包含了其它文件的名字以及指向与这些文件有关信息的指针。对于一个目录有读权限的任一进程都可以读取该目录的内容，但是只有内核可以直接写目录文件，进程必须调用系统函数才能更改目录；</p>
</li>
<li><p><strong>块特殊文件</strong>，提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行；</p>
</li>
<li><p><strong>字符特殊文件</strong>，提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件（FreeBSD不再支持块特殊文件，对设备的所有访问需要通过字符特殊文件进行）；</p>
</li>
<li><p><strong>FIFO</strong>，用于进程间通信，有时也称为命名管道；</p>
</li>
<li><p><strong>套接字</strong>，用于进程间的网络通信，套接字也可用于在一台机子上进程之间的非网络通信；</p>
</li>
<li><p><strong>符号链接</strong>，这种类型的文件指向另一个文件；</p>
</li>
</ul>
<h4 id="3-1-基本函数"><a href="#3-1-基本函数" class="headerlink" title="3.1. 基本函数"></a>3.1. 基本函数</h4><h5 id="3-1-1-stat、fstat、fstatat、lstat"><a href="#3-1-1-stat、fstat、fstatat、lstat" class="headerlink" title="3.1.1. stat、fstat、fstatat、lstat"></a>3.1.1. stat、fstat、fstatat、lstat</h5><figure class="highlight c"><figcaption><span class="fileDir">sys/</span><span class="caption">stat.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>stat</code>函数可以返回与命名文件相关的信息结构，<code>fstat</code>函数获取已在描述符fd上打开文件的有关信息。<code>lstat</code>与<code>stat</code>类似，但是当命名文件是一个符号链接时，其返回的是符号链接的有关信息，而不是所指向的文件信息。    </p>
<p><code>fstatat</code>函数为一个相对于当前打开目录的路径名返回的统计信息，参数<code>flag</code>控制着是否跟随着一个符号链接，如果设置为<code>AT_SYMLINK_NOFOLLOW</code>，将返回符号链接本身的信息，而默认返回的是符号链接所指向的实际文件信息。如果参数<code>pathname</code>是一个绝对路径，参数<code>fd</code>将被忽略，而如果是一个相对路径，并且<code>fd</code>的值为<code>AT_FDCWD</code>，将会计算相对于当前目录的<code>pathname</code></p>
<p>参数<code>buf</code>是一个指针，它指向一个必须提供的结构，然后函数中会负责来填充信息。结构的实际定义可能随具体实现会有所不同，但其基本形式可以如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">    <span class="keyword">mode_t</span>          st_mode;     <span class="comment">/* file type &amp; mode(permissions) */</span>     </span><br><span class="line">    <span class="keyword">ino_t</span>           st_ino;      <span class="comment">/* i-node number(serial number) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_dev;      <span class="comment">/* device number(file system) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_rdev;     <span class="comment">/* device number for special files */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>         st_nlink;    <span class="comment">/* number of links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>           st_uid;      <span class="comment">/* user id of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>           st_gid;      <span class="comment">/* group id of owner */</span></span><br><span class="line">    <span class="keyword">off_t</span>           st_size;     <span class="comment">/* size in bytes, for regular files */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atime</span>;</span>    <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtime</span>;</span>    <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctime</span>;</span>    <span class="comment">/* time of last file status change */</span></span><br><span class="line">    <span class="keyword">blksize_t</span>       st_blksize;  <span class="comment">/* best I/O block size */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>        st_blocks;   <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-示例：获取文件类型"><a href="#3-2-示例：获取文件类型" class="headerlink" title="3.2. 示例：获取文件类型"></a>3.2. 示例：获取文件类型</h4><figure class="highlight c"><figcaption><span class="caption">vim gettype.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>    i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span>(lstat(argv[i], &amp;buf) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"lstat error"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"普通文件"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"目录文件"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISCHR(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"字符特殊文件"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"块特殊文件"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"管道或FIFO"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"符号链接"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">"套接字"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ptr = <span class="string">"unknown mode"</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span class="caption">gcc gettype.c -o gettype</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;passwd: 普通文件</span><br><span class="line">&#x2F;etc: 目录文件</span><br><span class="line">&#x2F;dev&#x2F;log: 套接字</span><br><span class="line">&#x2F;dev&#x2F;tty: 字符特殊文件</span><br><span class="line">&#x2F;dev&#x2F;sr0: 块特殊文件</span><br><span class="line">&#x2F;dev&#x2F;cdrom: 符号链接</span><br></pre></td></tr></table></figure>
<h3 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4. 文件系统"></a>4. 文件系统</h3><p>这里介绍下UNIX文件系统的基本结构，同时，了解下<code>i</code>节点和指向<code>i</code>节点的目录项之间的区别。可以将一个磁盘分成多个区，每个区包含一个文件系统</p>
<p><img src="/img/20200601/20200601.3.jpg" alt=""> </p>
<p><code>i</code>节点是固定长度的记录项，它包含有关文件的大部分信息，每个<code>i</code>节点中都有一个链接计数（如下图，有两个目录项指向同一个<code>i</code>节点），表示指向该<code>i</code>节点的目录项数，只有当链接计数为<code>0</code>时，才可以删除文件，即释放文件占用的数据块。这就意味着解除一个文件的链接，并不等于释放文件占用的数据块，这也是为什么删除一个目录项的函数命名为<code>unlink</code>而不是<code>delete</code>的原因。</p>
<p><code>i</code>节点包含了文件有关的所有信息，如文件类型、访问权限位、文件长度、指向文件数据块的指针等。<code>stat</code>结构中的大多数信息都取自<code>i</code>节点，只有两项重要数据存放在目录项中：文件名和<code>i</code>节点编号。只是一个目录项不能指向另一个文件系统的<code>i</code>节点，在不更换文件系统的情况下进行<code>mv</code>文件重命名时，实际并未发生文件移到，只需构造一个指向先有<code>i</code>节点的新目录项，并删除旧的目录项。</p>
<p>另一种链接类型为符号链接，符号链接文件在其指向的数据块中包含了链接指向的文件的名字。可以理解为硬链接与原文件名指向了同样的<code>i</code>节点，而软链接间接的指向了原文件名，然后再定位到原文件的<code>i</code>节点。两者的区别可以用如下示例体现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">touch target.txt</span><br><span class="line">ln target.txt target.lnk</span><br><span class="line">ln -s target.txt target.lnk.soft</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除后，target.lnk正常，而target.lnk.soft没有内容，因为其对应的数据块被释放了</span></span><br><span class="line">rm -f target.txt</span><br></pre></td></tr></table></figure>
<p><img src="/img/20200601/20200601.4.jpg" alt=""> </p>
<p>考虑目录文件的链接计数，如果为叶子目录，则链接数为2，链接来自于命名该目录的目录项，以及该目录中的<code>.</code>项。如果存在子目录，则链接数至少为3，链接来自其子目录中的<code>..</code>项，每个子目录都会使其父目录的链接数加1。</p>
<p><img src="/img/20200601/20200601.5.jpg" alt=""> </p>
<h4 id="4-1-基本函数"><a href="#4-1-基本函数" class="headerlink" title="4.1. 基本函数"></a>4.1. 基本函数</h4><ul>
<li><strong>link、linkat、unlink、unlinkat、remove</strong></li>
</ul>
<h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1. ls"></a>1. ls</h3><figure class="highlight c"><figcaption><span class="caption">vim test.ls.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    DIR           *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">        err_sys(<span class="string">"usage: ls dir_name"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_quit(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-fork"><a href="#3-fork" class="headerlink" title="3. fork"></a>3. fork</h3><figure class="highlight c"><figcaption><span class="caption">vim test.fork.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var_globe = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"a write to stdout\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var_local = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) != <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)</span><br><span class="line">        err_sys(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        var_globe++;</span><br><span class="line">        var_local++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程："</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程："</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid=%ld, parentPid=%ld, globe=%d, local=%d\n"</span>, getpid(), (<span class="keyword">long</span>)getppid(), var_globe, var_local);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span class="fileDir">gcc test.fork.c -o fork && ./</span><span class="caption">fork</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">子进程：pid&#x3D;23401, parentPid&#x3D;23400, globe&#x3D;7, local&#x3D;89</span><br><span class="line">父进程：pid&#x3D;23400, parentPid&#x3D;23207, globe&#x3D;6, local&#x3D;88</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span class="fileDir">gcc test.fork.c -o fork && ./</span><span class="caption">fork > tmp.txt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">子进程：pid&#x3D;23465, parentPid&#x3D;23464, globe&#x3D;7, local&#x3D;89</span><br><span class="line">before fork</span><br><span class="line">父进程：pid&#x3D;23464, parentPid&#x3D;23207, globe&#x3D;6, local&#x3D;88</span><br></pre></td></tr></table></figure>
<h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><figure class="highlight c"><figcaption><span class="caption">apue.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;      /* for definition of errno */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;     /* ISO C variable aruments */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">err_doit</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, va_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Nonfatal error related to a system call.</span></span><br><span class="line"><span class="comment"> * Print a message and return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_ret</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">1</span>, errno, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fatal error related to a system call.</span></span><br><span class="line"><span class="comment"> * Print a message and terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_sys</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">1</span>, errno, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fatal error unrelated to a system call.</span></span><br><span class="line"><span class="comment"> * Error code passed as explict parameter.</span></span><br><span class="line"><span class="comment"> * Print a message and terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">1</span>, error, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fatal error related to a system call.</span></span><br><span class="line"><span class="comment"> * Print a message, dump core, and terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_dump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">1</span>, errno, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">abort</span>();        <span class="comment">/* dump core and terminate */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);        <span class="comment">/* shouldn't get here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Nonfatal error unrelated to a system call.</span></span><br><span class="line"><span class="comment"> * Print a message and return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">0</span>, <span class="number">0</span>, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fatal error unrelated to a system call.</span></span><br><span class="line"><span class="comment"> * Print a message and terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_quit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;</span><br><span class="line">    va_list     ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    err_doit(<span class="number">0</span>, <span class="number">0</span>, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Print a message and return to caller.</span></span><br><span class="line"><span class="comment"> * Caller specifies "errnoflag".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">err_doit</span><span class="params">(<span class="keyword">int</span> errnoflag, <span class="keyword">int</span> error, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>    buf[MAXLINE];</span><br><span class="line">   vsnprintf(buf, MAXLINE, fmt, ap);</span><br><span class="line">   <span class="keyword">if</span> (errnoflag)</span><br><span class="line">       <span class="built_in">snprintf</span>(buf + <span class="built_in">strlen</span>(buf), MAXLINE - <span class="built_in">strlen</span>(buf), <span class="string">": %s"</span>, strerror(error));</span><br><span class="line">   <span class="built_in">strcat</span>(buf, <span class="string">"\n"</span>);</span><br><span class="line">   fflush(<span class="built_in">stdout</span>);     <span class="comment">/* in case stdout and stderr are the same */</span></span><br><span class="line">   <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">   fflush(<span class="literal">NULL</span>);       <span class="comment">/* flushes all stdio output streams */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><strong>参考：</strong></p>
<ol>
<li>《UNIX环境高级编程》</li>
<li><a href="http://www.apuebook.com/apue3e.html" target="_blank" rel="noopener">http://www.apuebook.com/apue3e.html</a></li>
</ol>

      
    </div>
	
    <footer>
      
	  
	    
	<nav id="pagination">
	  
		  <a class="alignleft prev" href="/2020/10/15/20201015/">
		    vim 日常操作
		  </a>
	  
	  
	  
		  <a class="alignright next" href="/2020/01/15/20200115/">
		    任务管理工具spring-fom 使用示例
		  </a>
	  
	  <div class="clearfix"></div>
	</nav>
	
	    
        
  
  <div class="categories">
    <a href="/categories/UNIX环境高级编程/">UNIX环境高级编程</a>
  </div>


        
  
  <div class="tags">
    <a href="/tags/I-O/">I/O</a>
  </div>


         		        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd7beb7890a79c73a3e3d',
        clientSecret: '80ea1fc195ae4b80cbd65ec9f1ce68d59595af4b',
        id: md5(window.location.pathname),
        repo: 'shanhm1991.github.io',
        owner: 'shanhm1991',
        admin: 'shanhm1991'
    })
    gitalk.render('gitalk-container')
</script>                              



</div></div>
    <aside id="sidebar" class="alignright">
  


  

<script src="/js/jquery-3.4.1.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $("#os_ul").click(function(){ $("#os_li").toggle(); });
    $("#xx_ul").click(function(){ $("#xx_li").toggle(); });
});
</script>


  

  
<div class="widget catlog">
<h3 class="title">Catlog</h3>
<ul class="entry_catlog">
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-文件描述符"><span class="toc-text">1. 文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-基本函数"><span class="toc-text">1.1. 基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-open、openat"><span class="toc-text">1.1.1. open、openat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-creat"><span class="toc-text">1.1.2. creat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-close"><span class="toc-text">1.1.3. close</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-lseek"><span class="toc-text">1.1.4. lseek</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-5-read、write"><span class="toc-text">1.1.5. read、write</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-示例：cp"><span class="toc-text">1.2. 示例：cp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-共享文件"><span class="toc-text">2. 共享文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-基本函数"><span class="toc-text">2.1. 基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-pread、pwrite"><span class="toc-text">2.1.1. pread、pwrite</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-dup、dup2"><span class="toc-text">2.1.2. dup、dup2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-sync、fsync、fdatasync"><span class="toc-text">2.1.3. sync、fsync、fdatasync</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4-fcnt1"><span class="toc-text">2.1.4. fcnt1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-文件类型"><span class="toc-text">3. 文件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-基本函数"><span class="toc-text">3.1. 基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-stat、fstat、fstatat、lstat"><span class="toc-text">3.1.1. stat、fstat、fstatat、lstat</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-示例：获取文件类型"><span class="toc-text">3.2. 示例：获取文件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-文件系统"><span class="toc-text">4. 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-基本函数"><span class="toc-text">4.1. 基本函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ls"><span class="toc-text">1. ls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-fork"><span class="toc-text">3. fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附录："><span class="toc-text">附录：</span></a></li></ol>
</div>





  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">

  
  
      &copy; 2017-2023 &nbsp;&nbsp; shanhm1991 &nbsp;&nbsp; version@1.0.0 
  
  
  
  <font style="float: right">
</div>
<div class="clearfix"></div>
</footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
